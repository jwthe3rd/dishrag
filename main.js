/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HelloWorldPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/ollama/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path = require("path");

// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers2(headers) {
  this.map = {};
  if (headers instanceof Headers2) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers2.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers2.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers2.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers2.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers2.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers2.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers2.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers2.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers2.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve2, reject) {
    reader.onload = function() {
      resolve2(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers2(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers2(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers2();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers2(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers2(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve2, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve2(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch2;
  g.Headers = Headers2;
  g.Request = Request;
  g.Response = Response;
}

// node_modules/ollama/dist/browser.mjs
var defaultPort = "11434";
var defaultHost = `http://127.0.0.1:${defaultPort}`;
var version = "0.5.15";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  var _a;
  if (typeof window !== "undefined" && window.navigator) {
    const nav = navigator;
    if ("userAgentData" in nav && ((_a = nav.userAgentData) == null ? void 0 : _a.platform)) {
      return `${nav.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};`;
    }
    if (navigator.platform) {
      return `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
    }
    return `unknown Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
function normalizeHeaders(headers) {
  if (headers instanceof Headers) {
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  } else if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  } else {
    return headers || {};
  }
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  options.headers = normalizeHeaders(options.headers);
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p) => p !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return defaultHost;
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = defaultPort;
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let auth = "";
  if (url.username) {
    auth = url.username;
    if (url.password) {
      auth += `:${url.password}`;
    }
    auth += "@";
  }
  let formattedHost = `${url.protocol}//${auth}${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField(this, "config");
    __publicField(this, "fetch");
    __publicField(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : defaultHost);
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      ...request
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/ollama/dist/index.mjs
var Ollama2 = class extends Ollama$1 {
  async encodeImage(image) {
    if (typeof image !== "string") {
      return Buffer.from(image).toString("base64");
    }
    try {
      if (import_fs.default.existsSync(image)) {
        const fileBuffer = await import_fs.promises.readFile((0, import_path.resolve)(image));
        return Buffer.from(fileBuffer).toString("base64");
      }
    } catch (e) {
    }
    return image;
  }
  /**
   * checks if a file exists
   * @param path {string} - The path to the file
   * @private @internal
   * @returns {Promise<boolean>} - Whether the file exists or not
   */
  async fileExists(path) {
    try {
      await import_fs.promises.access(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  async create(request) {
    if (request.from && await this.fileExists((0, import_path.resolve)(request.from))) {
      throw Error("Creating with a local path is not currently supported from ollama-js");
    }
    if (request.stream) {
      return super.create(request);
    } else {
      return super.create(request);
    }
  }
};
var index = new Ollama2();

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var HelloWorldPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("dice", "Sample Plugin", (evt) => {
      new import_obsidian.Notice("This is a notice!");
    });
    ribbonIconEl.addClass("my-plugin-ribbon-class");
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Status Bar Text");
    this.addCommand({
      id: "open-sample-modal-simple",
      name: "Open sample modal (simple)",
      callback: () => {
        new SampleModal(this.app).open();
      }
    });
    this.addCommand({
      id: "sample-editor-command",
      name: "Sample editor command",
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        editor.replaceSelection("Sample Editor Command");
      }
    });
    this.addRibbonIcon("dice", "Greet", async () => {
      try {
        const test = await index.embeddings({ model: "nomic-embed-text", prompt: "The sky is blue because of rayleigh scattering" });
        new import_obsidian.Notice(JSON.stringify(test, null, 2));
      } catch (err) {
        console.error("Error generating embeddings", err);
        new import_obsidian.Notice("Error in ollama");
      }
    });
    this.addCommand({
      id: "spit_out_reply",
      name: "Query Local LLM (non-RAG)",
      editorCallback: async (editor, view) => {
        console.log(editor.getSelection());
        const prompt = editor.getSelection();
        if (!prompt) {
          new import_obsidian.Notice("No prompt selected!");
          return;
        }
        const test = await index.chat({ model: "deepseek-r1:7b", messages: [{ role: "user", content: JSON.stringify(prompt) }] });
        editor.replaceSelection(JSON.stringify(test.message.content));
      }
    });
    this.addCommand({
      id: "spit_out_reply_simple_rule",
      name: "Query Local LLM (with simple rules)",
      editorCallback: async (editor, view) => {
        const prompt = editor.getSelection();
        const ruleFilePath = "Projects/dishrag/dishragrules.md";
        const file = this.app.vault.getFileByPath(ruleFilePath);
        new import_obsidian.Notice("Successfully read rules file!");
        if (!prompt) {
          new import_obsidian.Notice("No prompt selected!");
          return;
        }
        if (file === null) {
          new import_obsidian.Notice("Rule file is not present!");
          return;
        }
        const content = await this.app.vault.read(file);
        const ruleGenContext = content;
        const gen_prompt = JSON.stringify(prompt).concat(JSON.stringify(ruleGenContext));
        new import_obsidian.Notice("Generating Response!");
        const test = await index.chat({ model: "deepseek-r1:7b", messages: [{ role: "user", content: gen_prompt }] });
        editor.replaceSelection(test.message.content.replace(/<think>[\s\S]*?<\/think>/g, "").trim());
      }
    });
    this.addCommand({
      id: "spit_out_reply_plaintext_rag",
      name: "Query Local LLM (with plaintext RAG)",
      editorCallback: async (editor, view) => {
        const prompt = editor.getSelection();
        const ragFilePath = "Projects/dishrag/dishragrules.md";
        const ruleFile = this.app.vault.getFileByPath(ragFilePath);
        new import_obsidian.Notice("Successfully read rules file!");
        if (!prompt) {
          new import_obsidian.Notice("No prompt selected!");
          return;
        }
        if (ruleFile === null) {
          new import_obsidian.Notice("Rules file is not present!");
          return;
        }
        let plain_rag_context = "";
        for (const file of this.app.vault.getMarkdownFiles()) {
          if (file.path.startsWith("Templates/"))
            continue;
          const content = await this.app.vault.read(file);
          plain_rag_context += `

 --- 
# ${file.basename}

${content}`;
        }
        new import_obsidian.Notice("Added context from the current Obsidian Vault!");
        const rules = await this.app.vault.read(ruleFile);
        const gen_prompt = JSON.stringify(plain_rag_context).concat(JSON.stringify(prompt).concat(JSON.stringify(rules)));
        new import_obsidian.Notice("Generating Response!");
        const test = await index.chat({ model: "deepseek-r1:7b", messages: [{ role: "user", content: gen_prompt }] });
        editor.replaceSelection(test.message.content.replace(/<think>[\s\S]*?<\/think>/g, "").trim());
      }
    });
    this.addCommand({
      id: "open-sample-modal-complex",
      name: "Open sample modal (complex)",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            new SampleModal(this.app).open();
          }
          return true;
        }
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.registerDomEvent(document, "click", (evt) => {
      console.log("click", evt);
    });
    this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText("Woah!");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvb2xsYW1hL2Rpc3QvaW5kZXgubWpzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L2Jyb3dzZXIubWpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBNb2RhbCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgb2xsYW1hIGZyb20gJ29sbGFtYSdcbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxuLy9cblxuXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG5cdG15U2V0dGluZzogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xuXHRteVNldHRpbmc6ICdkZWZhdWx0J1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxsb1dvcmxkUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IE15UGx1Z2luU2V0dGluZ3M7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHQvLyBUaGlzIGNyZWF0ZXMgYW4gaWNvbiBpbiB0aGUgbGVmdCByaWJib24uXG5cdFx0Y29uc3QgcmliYm9uSWNvbkVsID0gdGhpcy5hZGRSaWJib25JY29uKCdkaWNlJywgJ1NhbXBsZSBQbHVnaW4nLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHQvLyBDYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGljb24uXG5cdFx0XHRuZXcgTm90aWNlKCdUaGlzIGlzIGEgbm90aWNlIScpO1xuXHRcdH0pO1xuXHRcdC8vIFBlcmZvcm0gYWRkaXRpb25hbCB0aGluZ3Mgd2l0aCB0aGUgcmliYm9uXG5cdFx0cmliYm9uSWNvbkVsLmFkZENsYXNzKCdteS1wbHVnaW4tcmliYm9uLWNsYXNzJyk7XG5cblx0XHQvLyBUaGlzIGFkZHMgYSBzdGF0dXMgYmFyIGl0ZW0gdG8gdGhlIGJvdHRvbSBvZiB0aGUgYXBwLiBEb2VzIG5vdCB3b3JrIG9uIG1vYmlsZSBhcHBzLlxuXHRcdGNvbnN0IHN0YXR1c0Jhckl0ZW1FbCA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xuXHRcdHN0YXR1c0Jhckl0ZW1FbC5zZXRUZXh0KCdTdGF0dXMgQmFyIFRleHQnKTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNpbXBsZSBjb21tYW5kIHRoYXQgY2FuIGJlIHRyaWdnZXJlZCBhbnl3aGVyZVxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ29wZW4tc2FtcGxlLW1vZGFsLXNpbXBsZScsXG5cdFx0XHRuYW1lOiAnT3BlbiBzYW1wbGUgbW9kYWwgKHNpbXBsZSknLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0bmV3IFNhbXBsZU1vZGFsKHRoaXMuYXBwKS5vcGVuKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ly8gVGhpcyBhZGRzIGFuIGVkaXRvciBjb21tYW5kIHRoYXQgY2FuIHBlcmZvcm0gc29tZSBvcGVyYXRpb24gb24gdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc2FtcGxlLWVkaXRvci1jb21tYW5kJyxcblx0XHRcdG5hbWU6ICdTYW1wbGUgZWRpdG9yIGNvbW1hbmQnLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKCdTYW1wbGUgRWRpdG9yIENvbW1hbmQnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkUmliYm9uSWNvbignZGljZScsICdHcmVldCcsIGFzeW5jICgpID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRjb25zdCB0ZXN0ID0gYXdhaXQgb2xsYW1hLmVtYmVkZGluZ3MoeyBtb2RlbDogJ25vbWljLWVtYmVkLXRleHQnLCBwcm9tcHQ6ICdUaGUgc2t5IGlzIGJsdWUgYmVjYXVzZSBvZiByYXlsZWlnaCBzY2F0dGVyaW5nJyB9KTtcblx0XHRcdG5ldyBOb3RpY2UoSlNPTi5zdHJpbmdpZnkodGVzdCxudWxsLDIpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZ3MnLCBlcnIpO1xuXHRcdFx0XHRuZXcgTm90aWNlKCdFcnJvciBpbiBvbGxhbWEnKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3NwaXRfb3V0X3JlcGx5Jyxcblx0XHRcdG5hbWU6ICdRdWVyeSBMb2NhbCBMTE0gKG5vbi1SQUcpJyxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBwcm9tcHQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0aWYgKCFwcm9tcHQpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm8gcHJvbXB0IHNlbGVjdGVkIVwiKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0ZXN0ID0gYXdhaXQgb2xsYW1hLmNoYXQoeyBtb2RlbDogJ2RlZXBzZWVrLXIxOjdiJywgbWVzc2FnZXM6IFt7cm9sZTogJ3VzZXInLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShwcm9tcHQpfV0gfSk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKEpTT04uc3RyaW5naWZ5KHRlc3QubWVzc2FnZS5jb250ZW50KSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3BpdF9vdXRfcmVwbHlfc2ltcGxlX3J1bGUnLFxuXHRcdFx0bmFtZTogJ1F1ZXJ5IExvY2FsIExMTSAod2l0aCBzaW1wbGUgcnVsZXMpJyxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBwcm9tcHQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdGNvbnN0IHJ1bGVGaWxlUGF0aCA9IFwiUHJvamVjdHMvZGlzaHJhZy9kaXNocmFncnVsZXMubWRcIjtcblx0XHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVCeVBhdGgocnVsZUZpbGVQYXRoKTtcblxuXHRcdFx0XHRuZXcgTm90aWNlKCdTdWNjZXNzZnVsbHkgcmVhZCBydWxlcyBmaWxlIScpO1xuXG5cdFx0XHRcdGlmICghcHJvbXB0KSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIHByb21wdCBzZWxlY3RlZCFcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGZpbGUgPT09IG51bGwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiUnVsZSBmaWxlIGlzIG5vdCBwcmVzZW50IVwiKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcblxuXHRcdFx0XHRjb25zdCBydWxlR2VuQ29udGV4dCA9IGNvbnRlbnQ7Ly9hd2FpdCBvbGxhbWEuZW1iZWRkaW5ncyh7bW9kZWw6ICdub21pYy1lbWJlZC10ZXh0JywgcHJvbXB0OiBKU09OLnN0cmluZ2lmeShjb250ZW50KX0pO1xuXG5cdFx0XHRcdGNvbnN0IGdlbl9wcm9tcHQgPSBKU09OLnN0cmluZ2lmeShwcm9tcHQpLmNvbmNhdChKU09OLnN0cmluZ2lmeShydWxlR2VuQ29udGV4dCkpO1xuXG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0dlbmVyYXRpbmcgUmVzcG9uc2UhJyk7XG5cdFx0XHRcdGNvbnN0IHRlc3QgPSBhd2FpdCBvbGxhbWEuY2hhdCh7IG1vZGVsOiAnZGVlcHNlZWstcjE6N2InLCBtZXNzYWdlczogW3tyb2xlOiAndXNlcicsIGNvbnRlbnQ6IGdlbl9wcm9tcHR9XSB9KTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24odGVzdC5tZXNzYWdlLmNvbnRlbnQucmVwbGFjZSgvPHRoaW5rPltcXHNcXFNdKj88XFwvdGhpbms+L2csICcnKS50cmltKCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3NwaXRfb3V0X3JlcGx5X3BsYWludGV4dF9yYWcnLFxuXHRcdFx0bmFtZTogJ1F1ZXJ5IExvY2FsIExMTSAod2l0aCBwbGFpbnRleHQgUkFHKScsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgcHJvbXB0ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRjb25zdCByYWdGaWxlUGF0aCA9IFwiUHJvamVjdHMvZGlzaHJhZy9kaXNocmFncnVsZXMubWRcIjtcblx0XHRcdFx0Y29uc3QgcnVsZUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRGaWxlQnlQYXRoKHJhZ0ZpbGVQYXRoKTtcblxuXHRcdFx0XHRuZXcgTm90aWNlKCdTdWNjZXNzZnVsbHkgcmVhZCBydWxlcyBmaWxlIScpO1xuXG5cdFx0XHRcdGlmICghcHJvbXB0KSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIHByb21wdCBzZWxlY3RlZCFcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJ1bGVGaWxlID09PSBudWxsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlJ1bGVzIGZpbGUgaXMgbm90IHByZXNlbnQhXCIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBwbGFpbl9yYWdfY29udGV4dCA9IFwiXCI7XG5cblx0XHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aCgnVGVtcGxhdGVzLycpKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuXHRcdFx0XHRcdHBsYWluX3JhZ19jb250ZXh0ICs9IGBcXG5cXG4gLS0tIFxcbiMgJHtmaWxlLmJhc2VuYW1lfVxcblxcbiR7Y29udGVudH1gO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3IE5vdGljZShcIkFkZGVkIGNvbnRleHQgZnJvbSB0aGUgY3VycmVudCBPYnNpZGlhbiBWYXVsdCFcIilcblxuXHRcdFx0XHRjb25zdCBydWxlcyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQocnVsZUZpbGUpO1xuXG5cdFx0XHRcdGNvbnN0IGdlbl9wcm9tcHQgPSBKU09OLnN0cmluZ2lmeShwbGFpbl9yYWdfY29udGV4dCkuY29uY2F0KEpTT04uc3RyaW5naWZ5KHByb21wdCkuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJ1bGVzKSkpO1xuXG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0dlbmVyYXRpbmcgUmVzcG9uc2UhJyk7XG5cdFx0XHRcdGNvbnN0IHRlc3QgPSBhd2FpdCBvbGxhbWEuY2hhdCh7IG1vZGVsOiAnZGVlcHNlZWstcjE6N2InLCBtZXNzYWdlczogW3tyb2xlOiAndXNlcicsIGNvbnRlbnQ6IGdlbl9wcm9tcHR9XSB9KTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24odGVzdC5tZXNzYWdlLmNvbnRlbnQucmVwbGFjZSgvPHRoaW5rPltcXHNcXFNdKj88XFwvdGhpbms+L2csICcnKS50cmltKCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIFRoaXMgYWRkcyBhIGNvbXBsZXggY29tbWFuZCB0aGF0IGNhbiBjaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhcHAgYWxsb3dzIGV4ZWN1dGlvbiBvZiB0aGUgY29tbWFuZFxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ29wZW4tc2FtcGxlLW1vZGFsLWNvbXBsZXgnLFxuXHRcdFx0bmFtZTogJ09wZW4gc2FtcGxlIG1vZGFsIChjb21wbGV4KScsXG5cdFx0XHRjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcblx0XHRcdFx0Ly8gQ29uZGl0aW9ucyB0byBjaGVja1xuXHRcdFx0XHRjb25zdCBtYXJrZG93blZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuXHRcdFx0XHRpZiAobWFya2Rvd25WaWV3KSB7XG5cdFx0XHRcdFx0Ly8gSWYgY2hlY2tpbmcgaXMgdHJ1ZSwgd2UncmUgc2ltcGx5IFwiY2hlY2tpbmdcIiBpZiB0aGUgY29tbWFuZCBjYW4gYmUgcnVuLlxuXHRcdFx0XHRcdC8vIElmIGNoZWNraW5nIGlzIGZhbHNlLCB0aGVuIHdlIHdhbnQgdG8gYWN0dWFsbHkgcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuXHRcdFx0XHRcdGlmICghY2hlY2tpbmcpIHtcblx0XHRcdFx0XHRcdG5ldyBTYW1wbGVNb2RhbCh0aGlzLmFwcCkub3BlbigpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRoaXMgY29tbWFuZCB3aWxsIG9ubHkgc2hvdyB1cCBpbiBDb21tYW5kIFBhbGV0dGUgd2hlbiB0aGUgY2hlY2sgZnVuY3Rpb24gcmV0dXJucyB0cnVlXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTYW1wbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cblx0XHQvLyBJZiB0aGUgcGx1Z2luIGhvb2tzIHVwIGFueSBnbG9iYWwgRE9NIGV2ZW50cyAob24gcGFydHMgb2YgdGhlIGFwcCB0aGF0IGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgcGx1Z2luKVxuXHRcdC8vIFVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGlzIHBsdWdpbiBpcyBkaXNhYmxlZC5cblx0XHR0aGlzLnJlZ2lzdGVyRG9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCdjbGljaycsIGV2dCk7XG5cdFx0fSk7XG5cblx0XHQvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cblx0XHR0aGlzLnJlZ2lzdGVySW50ZXJ2YWwod2luZG93LnNldEludGVydmFsKCgpID0+IGNvbnNvbGUubG9nKCdzZXRJbnRlcnZhbCcpLCA1ICogNjAgKiAxMDAwKSk7XG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblxuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cblxuY2xhc3MgU2FtcGxlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0fVxuXG5cdG9uT3BlbigpIHtcblx0XHRjb25zdCB7Y29udGVudEVsfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLnNldFRleHQoJ1dvYWghJyk7XG5cdH1cblxuXHRvbkNsb3NlKCkge1xuXHRcdGNvbnN0IHtjb250ZW50RWx9ID0gdGhpcztcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcblx0fVxufVxuXG5jbGFzcyBTYW1wbGVTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogSGVsbG9Xb3JsZFBsdWdpbjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBIZWxsb1dvcmxkUGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTZXR0aW5nICMxJylcblx0XHRcdC5zZXREZXNjKCdJdFxcJ3MgYSBzZWNyZXQnKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBzZWNyZXQnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblx0fVxufVxuIiwgImltcG9ydCBmcywgeyBwcm9taXNlcyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IE9sbGFtYSBhcyBPbGxhbWEkMSB9IGZyb20gJy4vYnJvd3Nlci5tanMnO1xuaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5jbGFzcyBPbGxhbWEgZXh0ZW5kcyBPbGxhbWEkMSB7XG4gIGFzeW5jIGVuY29kZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGltYWdlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGltYWdlKSkge1xuICAgICAgICBjb25zdCBmaWxlQnVmZmVyID0gYXdhaXQgcHJvbWlzZXMucmVhZEZpbGUocmVzb2x2ZShpbWFnZSkpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlsZUJ1ZmZlcikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogY2hlY2tzIGlmIGEgZmlsZSBleGlzdHNcbiAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gLSBUaGUgcGF0aCB0byB0aGUgZmlsZVxuICAgKiBAcHJpdmF0ZSBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gV2hldGhlciB0aGUgZmlsZSBleGlzdHMgb3Igbm90XG4gICAqL1xuICBhc3luYyBmaWxlRXhpc3RzKHBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvbWlzZXMuYWNjZXNzKHBhdGgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZShyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QuZnJvbSAmJiBhd2FpdCB0aGlzLmZpbGVFeGlzdHMocmVzb2x2ZShyZXF1ZXN0LmZyb20pKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDcmVhdGluZyB3aXRoIGEgbG9jYWwgcGF0aCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBmcm9tIG9sbGFtYS1qc1wiKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3Quc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHJlcXVlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlKHJlcXVlc3QpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgaW5kZXggPSBuZXcgT2xsYW1hKCk7XG5cbmV4cG9ydCB7IE9sbGFtYSwgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uub2sgPSBmYWxzZVxuICByZXNwb25zZS5zdGF0dXMgPSAwXG4gIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gIHJldHVybiByZXNwb25zZVxufVxuXG52YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG59XG5cbmV4cG9ydCB2YXIgRE9NRXhjZXB0aW9uID0gZy5ET01FeGNlcHRpb25cbnRyeSB7XG4gIG5ldyBET01FeGNlcHRpb24oKVxufSBjYXRjaCAoZXJyKSB7XG4gIERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpXG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRE9NRXhjZXB0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICB4aHIuYWJvcnQoKVxuICAgIH1cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgY2hlY2sgaWYgc3BlY2lmaWNhbGx5IGZvciB3aGVuIGEgdXNlciBmZXRjaGVzIGEgZmlsZSBsb2NhbGx5IGZyb20gdGhlIGZpbGUgc3lzdGVtXG4gICAgICAvLyBPbmx5IGlmIHRoZSBzdGF0dXMgaXMgb3V0IG9mIGEgbm9ybWFsIHJhbmdlXG4gICAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwICYmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0gMjAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZy5sb2NhdGlvbi5ocmVmID8gZy5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlclxuICAgICAgKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzIHx8IChnLkhlYWRlcnMgJiYgaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgZy5IZWFkZXJzKSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZXMucHVzaChub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKVxuICAgICAgfSlcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gIH0pXG59XG5cbmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG5pZiAoIWcuZmV0Y2gpIHtcbiAgZy5mZXRjaCA9IGZldGNoXG4gIGcuSGVhZGVycyA9IEhlYWRlcnNcbiAgZy5SZXF1ZXN0ID0gUmVxdWVzdFxuICBnLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cbiIsICJpbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5cbmNvbnN0IGRlZmF1bHRQb3J0ID0gXCIxMTQzNFwiO1xuY29uc3QgZGVmYXVsdEhvc3QgPSBgaHR0cDovLzEyNy4wLjAuMToke2RlZmF1bHRQb3J0fWA7XG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuNS4xNVwiO1xuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHN0YXR1c19jb2RlKSB7XG4gICAgc3VwZXIoZXJyb3IpO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLnN0YXR1c19jb2RlID0gc3RhdHVzX2NvZGU7XG4gICAgdGhpcy5uYW1lID0gXCJSZXNwb25zZUVycm9yXCI7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFib3J0YWJsZUFzeW5jSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihhYm9ydENvbnRyb2xsZXIsIGl0ciwgZG9uZUNhbGxiYWNrKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWJvcnRDb250cm9sbGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIml0clwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJkb25lQ2FsbGJhY2tcIik7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgdGhpcy5pdHIgPSBpdHI7XG4gICAgdGhpcy5kb25lQ2FsbGJhY2sgPSBkb25lQ2FsbGJhY2s7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1lc3NhZ2Ugb2YgdGhpcy5pdHIpIHtcbiAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICB9XG4gICAgICB5aWVsZCBtZXNzYWdlO1xuICAgICAgaWYgKG1lc3NhZ2UuZG9uZSB8fCBtZXNzYWdlLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgdGhpcy5kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IHJlY2VpdmUgZG9uZSBvciBzdWNjZXNzIHJlc3BvbnNlIGluIHN0cmVhbS5cIik7XG4gIH1cbn1cbmNvbnN0IGNoZWNrT2sgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gIGxldCBlcnJvckRhdGEgPSBudWxsO1xuICBpZiAocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgIHRyeSB7XG4gICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBtZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IG1lc3NhZ2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIHBhcnNlIGVycm9yIHJlc3BvbnNlIGFzIEpTT05cIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkdldHRpbmcgdGV4dCBmcm9tIHJlc3BvbnNlXCIpO1xuICAgICAgY29uc3QgdGV4dFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbWVzc2FnZSA9IHRleHRSZXNwb25zZSB8fCBtZXNzYWdlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBnZXQgdGV4dCBmcm9tIGVycm9yIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihtZXNzYWdlLCByZXNwb25zZS5zdGF0dXMpO1xufTtcbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgY29uc3QgbmF2ID0gbmF2aWdhdG9yO1xuICAgIGlmIChcInVzZXJBZ2VudERhdGFcIiBpbiBuYXYgJiYgbmF2LnVzZXJBZ2VudERhdGE/LnBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gYCR7bmF2LnVzZXJBZ2VudERhdGEucGxhdGZvcm0udG9Mb3dlckNhc2UoKX0gQnJvd3Nlci8ke25hdmlnYXRvci51c2VyQWdlbnR9O2A7XG4gICAgfVxuICAgIGlmIChuYXZpZ2F0b3IucGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiBgJHtuYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKX0gQnJvd3Nlci8ke25hdmlnYXRvci51c2VyQWdlbnR9O2A7XG4gICAgfVxuICAgIHJldHVybiBgdW5rbm93biBCcm93c2VyLyR7bmF2aWdhdG9yLnVzZXJBZ2VudH07YDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBgJHtwcm9jZXNzLmFyY2h9ICR7cHJvY2Vzcy5wbGF0Zm9ybX0gTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbn1gO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVycyhoZWFkZXJzKSB7XG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoZWFkZXJzIHx8IHt9O1xuICB9XG59XG5jb25zdCBmZXRjaFdpdGhIZWFkZXJzID0gYXN5bmMgKGZldGNoLCB1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwiVXNlci1BZ2VudFwiOiBgb2xsYW1hLWpzLyR7dmVyc2lvbn0gKCR7Z2V0UGxhdGZvcm0oKX0pYFxuICB9O1xuICBvcHRpb25zLmhlYWRlcnMgPSBub3JtYWxpemVIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gIGNvbnN0IGN1c3RvbUhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5oZWFkZXJzKS5maWx0ZXIoKFtrZXldKSA9PiAhT2JqZWN0LmtleXMoZGVmYXVsdEhlYWRlcnMpLnNvbWUoKGRlZmF1bHRLZXkpID0+IGRlZmF1bHRLZXkudG9Mb3dlckNhc2UoKSA9PT0ga2V5LnRvTG93ZXJDYXNlKCkpKVxuICApO1xuICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgLi4uZGVmYXVsdEhlYWRlcnMsXG4gICAgLi4uY3VzdG9tSGVhZGVyc1xuICB9O1xuICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbn07XG5jb25zdCBnZXQgPSBhc3luYyAoZmV0Y2gsIGhvc3QsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBwb3N0ID0gYXN5bmMgKGZldGNoLCBob3N0LCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGlzUmVjb3JkID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpbnB1dCk7XG4gIH07XG4gIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBpc1JlY29yZChkYXRhKSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogZGF0YTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhIZWFkZXJzKGZldGNoLCBob3N0LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBmb3JtYXR0ZWREYXRhLFxuICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsLFxuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgZGVsID0gYXN5bmMgKGZldGNoLCBob3N0LCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IHBhcnNlSlNPTiA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGNvbnN0IHJlYWRlciA9IGl0ci5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgY29uc3QgcGFydHMgPSBidWZmZXIuc3BsaXQoXCJcXG5cIik7XG4gICAgYnVmZmVyID0gcGFydHMucG9wKCkgPz8gXCJcIjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIEpTT04ucGFyc2UocGFydCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIGpzb246IFwiLCBwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGJ1ZmZlci5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHApID0+IHAgIT09IFwiXCIpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkIEpTT04ucGFyc2UocGFydCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImludmFsaWQganNvbjogXCIsIHBhcnQpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGZvcm1hdEhvc3QgPSAoaG9zdCkgPT4ge1xuICBpZiAoIWhvc3QpIHtcbiAgICByZXR1cm4gZGVmYXVsdEhvc3Q7XG4gIH1cbiAgbGV0IGlzRXhwbGljaXRQcm90b2NvbCA9IGhvc3QuaW5jbHVkZXMoXCI6Ly9cIik7XG4gIGlmIChob3N0LnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgaG9zdCA9IGBodHRwOi8vMTI3LjAuMC4xJHtob3N0fWA7XG4gICAgaXNFeHBsaWNpdFByb3RvY29sID0gdHJ1ZTtcbiAgfVxuICBpZiAoIWlzRXhwbGljaXRQcm90b2NvbCkge1xuICAgIGhvc3QgPSBgaHR0cDovLyR7aG9zdH1gO1xuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoaG9zdCk7XG4gIGxldCBwb3J0ID0gdXJsLnBvcnQ7XG4gIGlmICghcG9ydCkge1xuICAgIGlmICghaXNFeHBsaWNpdFByb3RvY29sKSB7XG4gICAgICBwb3J0ID0gZGVmYXVsdFBvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcnQgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiO1xuICAgIH1cbiAgfVxuICBsZXQgYXV0aCA9IFwiXCI7XG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICBhdXRoID0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHtcbiAgICAgIGF1dGggKz0gYDoke3VybC5wYXNzd29yZH1gO1xuICAgIH1cbiAgICBhdXRoICs9IFwiQFwiO1xuICB9XG4gIGxldCBmb3JtYXR0ZWRIb3N0ID0gYCR7dXJsLnByb3RvY29sfS8vJHthdXRofSR7dXJsLmhvc3RuYW1lfToke3BvcnR9JHt1cmwucGF0aG5hbWV9YDtcbiAgaWYgKGZvcm1hdHRlZEhvc3QuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgZm9ybWF0dGVkSG9zdCA9IGZvcm1hdHRlZEhvc3Quc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZWRIb3N0O1xufTtcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xubGV0IE9sbGFtYSQxID0gY2xhc3MgT2xsYW1hIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmV0Y2hcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzXCIsIFtdKTtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGhvc3Q6IFwiXCIsXG4gICAgICBoZWFkZXJzOiBjb25maWc/LmhlYWRlcnNcbiAgICB9O1xuICAgIGlmICghY29uZmlnPy5wcm94eSkge1xuICAgICAgdGhpcy5jb25maWcuaG9zdCA9IGZvcm1hdEhvc3QoY29uZmlnPy5ob3N0ID8/IGRlZmF1bHRIb3N0KTtcbiAgICB9XG4gICAgdGhpcy5mZXRjaCA9IGNvbmZpZz8uZmV0Y2ggPz8gZmV0Y2g7XG4gIH1cbiAgLy8gQWJvcnQgYW55IG9uZ29pbmcgc3RyZWFtZWQgcmVxdWVzdHMgdG8gT2xsYW1hXG4gIGFib3J0KCkge1xuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgcmVxdWVzdCB0byB0aGUgT2xsYW1hIHNlcnZlci4gSWYgdGhlIHJlcXVlc3QgaXMgc3RyZWFtYWJsZSwgaXQgd2lsbCByZXR1cm4gYVxuICAgKiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSByZXNwb25zZSBtZXNzYWdlcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICogb2JqZWN0LlxuICAgKiBAcGFyYW0gZW5kcG9pbnQge3N0cmluZ30gLSBUaGUgZW5kcG9pbnQgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIHJlcXVlc3Qge29iamVjdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QgdG8gc2VuZCB0byB0aGUgZW5kcG9pbnQuXG4gICAqIEBwcm90ZWN0ZWQge1QgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFQ+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzXG4gICAqIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nIG9yIGlmIHRoZSByZXNwb25zZSBpcyBhbiBlcnJvci5cbiAgICogQHJldHVybnMge1Byb21pc2U8VCB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8VD4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBzdHJlYW1lZCByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIHByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChlbmRwb2ludCwgcmVxdWVzdCkge1xuICAgIHJlcXVlc3Quc3RyZWFtID0gcmVxdWVzdC5zdHJlYW0gPz8gZmFsc2U7XG4gICAgY29uc3QgaG9zdCA9IGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS8ke2VuZHBvaW50fWA7XG4gICAgaWYgKHJlcXVlc3Quc3RyZWFtKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGhvc3QsIHJlcXVlc3QsIHtcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2UyLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBib2R5XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRyID0gcGFyc2VKU09OKHJlc3BvbnNlMi5ib2R5KTtcbiAgICAgIGNvbnN0IGFib3J0YWJsZUFzeW5jSXRlcmF0b3IgPSBuZXcgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcihcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLFxuICAgICAgICBpdHIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cy5pbmRleE9mKGFib3J0YWJsZUFzeW5jSXRlcmF0b3IpO1xuICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMucHVzaChhYm9ydGFibGVBc3luY0l0ZXJhdG9yKTtcbiAgICAgIHJldHVybiBhYm9ydGFibGVBc3luY0l0ZXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgaG9zdCwgcmVxdWVzdCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gaW1hZ2UgdG8gYmFzZTY0IGlmIGl0IGlzIGEgVWludDhBcnJheS5cbiAgICogQHBhcmFtIGltYWdlIHtVaW50OEFycmF5IHwgc3RyaW5nfSAtIFRoZSBpbWFnZSB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIGJhc2U2NCBlbmNvZGVkIGltYWdlLlxuICAgKi9cbiAgYXN5bmMgZW5jb2RlSW1hZ2UoaW1hZ2UpIHtcbiAgICBpZiAodHlwZW9mIGltYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW1hZ2UpO1xuICAgICAgbGV0IGJ5dGVTdHJpbmcgPSBcIlwiO1xuICAgICAgY29uc3QgbGVuID0gdWludDhBcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBieXRlU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnRvYShieXRlU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSByZXNwb25zZSBmcm9tIGEgdGV4dCBwcm9tcHQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtHZW5lcmF0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW5lcmF0ZVJlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxHZW5lcmF0ZVJlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LmltYWdlcykge1xuICAgICAgcmVxdWVzdC5pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0LmltYWdlcy5tYXAodGhpcy5lbmNvZGVJbWFnZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImdlbmVyYXRlXCIsIHJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDaGF0cyB3aXRoIHRoZSBtb2RlbC4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIG1lc3NhZ2VzIHdpdGggaW1hZ2VzIHRoYXQgYXJlIGVpdGhlclxuICAgKiBVaW50OEFycmF5cyBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzLiBUaGUgaW1hZ2VzIHdpbGwgYmUgYmFzZTY0IGVuY29kZWQgYmVmb3JlIHNlbmRpbmcgdGhlXG4gICAqIHJlcXVlc3QuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDaGF0UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENoYXRSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8Q2hhdFJlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvciBhblxuICAgKiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgY2hhdChyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QubWVzc2FnZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXF1ZXN0Lm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmltYWdlcykge1xuICAgICAgICAgIG1lc3NhZ2UuaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBtZXNzYWdlLmltYWdlcy5tYXAodGhpcy5lbmNvZGVJbWFnZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiY2hhdFwiLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtb2RlbCBmcm9tIGEgc3RyZWFtIG9mIGRhdGEuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDcmVhdGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYSBzdHJlYW0gb2YgcHJvZ3Jlc3MgcmVzcG9uc2VzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJjcmVhdGVcIiwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWxscyBhIG1vZGVsIGZyb20gdGhlIE9sbGFtYSByZWdpc3RyeS4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIGEgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlXG4gICAqIHJlc3BvbnNlIHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1B1bGxSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHB1bGwocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcInB1bGxcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBpbnNlY3VyZTogcmVxdWVzdC5pbnNlY3VyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoZXMgYSBtb2RlbCB0byB0aGUgT2xsYW1hIHJlZ2lzdHJ5LiBUaGUgcmVxdWVzdCBvYmplY3QgY2FuIGNvbnRhaW4gYSBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGVcbiAgICogcmVzcG9uc2Ugc2hvdWxkIGJlIHN0cmVhbWVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7UHVzaFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmVzc1Jlc3BvbnNlIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxQcm9ncmVzc1Jlc3BvbnNlPj59IC0gVGhlIHJlc3BvbnNlIG9iamVjdCBvclxuICAgKiBhbiBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHRoYXQgeWllbGRzIHJlc3BvbnNlIG1lc3NhZ2VzLlxuICAgKi9cbiAgYXN5bmMgcHVzaChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwicHVzaFwiLCB7XG4gICAgICBuYW1lOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgc3RyZWFtOiByZXF1ZXN0LnN0cmVhbSxcbiAgICAgIGluc2VjdXJlOiByZXF1ZXN0Lmluc2VjdXJlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdG9cbiAgICogZGVsZXRlLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RGVsZXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YXR1c1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKHJlcXVlc3QpIHtcbiAgICBhd2FpdCBkZWwoXG4gICAgICB0aGlzLmZldGNoLFxuICAgICAgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2RlbGV0ZWAsXG4gICAgICB7IG5hbWU6IHJlcXVlc3QubW9kZWwgfSxcbiAgICAgIHsgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVycyB9XG4gICAgKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH07XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhIG1vZGVsIGZyb20gb25lIG5hbWUgdG8gYW5vdGhlci4gVGhlIHJlcXVlc3Qgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBuYW1lIG9mIHRoZVxuICAgKiBtb2RlbCB0byBjb3B5IGFuZCB0aGUgbmV3IG5hbWUuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtDb3B5UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YXR1c1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgY29weShyZXF1ZXN0KSB7XG4gICAgYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvY29weWAsIHsgLi4ucmVxdWVzdCB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgbW9kZWxzIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIGxpc3QoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3RhZ3NgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdGhlIG1ldGFkYXRhIG9mIGEgbW9kZWwuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtTaG93UmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNob3dSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNob3cocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvc2hvd2AsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW1iZWRzIHRleHQgaW5wdXQgaW50byB2ZWN0b3JzLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RW1iZWRSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RW1iZWRSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGVtYmVkKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2VtYmVkYCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbWJlZHMgYSB0ZXh0IHByb21wdCBpbnRvIGEgdmVjdG9yLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7RW1iZWRkaW5nc1JlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbWJlZGRpbmdzUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZGRpbmdzKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2VtYmVkZGluZ3NgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RzIHRoZSBydW5uaW5nIG1vZGVscyBvbiB0aGUgc2VydmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIHBzKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9wc2AsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG59O1xuY29uc3QgYnJvd3NlciA9IG5ldyBPbGxhbWEkMSgpO1xuXG5leHBvcnQgeyBPbGxhbWEkMSBhcyBPbGxhbWEsIGJyb3dzZXIgYXMgZGVmYXVsdCB9O1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBNEY7OztBQ0E1RixnQkFBNkI7QUFDN0Isa0JBQXdCOzs7QUNBeEIsSUFBSSxJQUNELE9BQU8sZUFBZSxlQUFlLGNBQ3JDLE9BQU8sU0FBUyxlQUFlO0FBRS9CLE9BQU8sV0FBVyxlQUFlLFVBQ2xDLENBQUM7QUFFSCxJQUFJLFVBQVU7QUFBQSxFQUNaLGNBQWMscUJBQXFCO0FBQUEsRUFDbkMsVUFBVSxZQUFZLEtBQUssY0FBYztBQUFBLEVBQ3pDLE1BQ0UsZ0JBQWdCLEtBQ2hCLFVBQVUsS0FDVCxXQUFXO0FBQ1YsUUFBSTtBQUNGLFVBQUksS0FBSztBQUNULGFBQU87QUFBQSxJQUNULFNBQVMsR0FBUDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRixFQUFHO0FBQUEsRUFDTCxVQUFVLGNBQWM7QUFBQSxFQUN4QixhQUFhLGlCQUFpQjtBQUNoQztBQUVBLFNBQVMsV0FBVyxLQUFLO0FBQ3ZCLFNBQU8sT0FBTyxTQUFTLFVBQVUsY0FBYyxHQUFHO0FBQ3BEO0FBRUEsSUFBSSxRQUFRLGFBQWE7QUFDbkIsZ0JBQWM7QUFBQSxJQUNoQjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUVJLHNCQUNGLFlBQVksVUFDWixTQUFTLEtBQUs7QUFDWixXQUFPLE9BQU8sWUFBWSxRQUFRLE9BQU8sVUFBVSxTQUFTLEtBQUssR0FBRyxDQUFDLElBQUk7QUFBQSxFQUMzRTtBQUNKO0FBakJNO0FBWUE7QUFPTixTQUFTLGNBQWMsTUFBTTtBQUMzQixNQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLFdBQU8sT0FBTyxJQUFJO0FBQUEsRUFDcEI7QUFDQSxNQUFJLDZCQUE2QixLQUFLLElBQUksS0FBSyxTQUFTLElBQUk7QUFDMUQsVUFBTSxJQUFJLFVBQVUsOENBQThDLE9BQU8sR0FBRztBQUFBLEVBQzlFO0FBQ0EsU0FBTyxLQUFLLFlBQVk7QUFDMUI7QUFFQSxTQUFTLGVBQWUsT0FBTztBQUM3QixNQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLFlBQVEsT0FBTyxLQUFLO0FBQUEsRUFDdEI7QUFDQSxTQUFPO0FBQ1Q7QUFHQSxTQUFTLFlBQVksT0FBTztBQUMxQixNQUFJLFdBQVc7QUFBQSxJQUNiLE1BQU0sV0FBVztBQUNmLFVBQUksUUFBUSxNQUFNLE1BQU07QUFDeEIsYUFBTyxFQUFDLE1BQU0sVUFBVSxRQUFXLE1BQVk7QUFBQSxJQUNqRDtBQUFBLEVBQ0Y7QUFFQSxNQUFJLFFBQVEsVUFBVTtBQUNwQixhQUFTLE9BQU8sUUFBUSxJQUFJLFdBQVc7QUFDckMsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBRUEsU0FBTztBQUNUO0FBRU8sU0FBU0EsU0FBUSxTQUFTO0FBQy9CLE9BQUssTUFBTSxDQUFDO0FBRVosTUFBSSxtQkFBbUJBLFVBQVM7QUFDOUIsWUFBUSxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ3BDLFdBQUssT0FBTyxNQUFNLEtBQUs7QUFBQSxJQUN6QixHQUFHLElBQUk7QUFBQSxFQUNULFdBQVcsTUFBTSxRQUFRLE9BQU8sR0FBRztBQUNqQyxZQUFRLFFBQVEsU0FBUyxRQUFRO0FBQy9CLFVBQUksT0FBTyxVQUFVLEdBQUc7QUFDdEIsY0FBTSxJQUFJLFVBQVUsd0VBQXdFLE9BQU8sTUFBTTtBQUFBLE1BQzNHO0FBQ0EsV0FBSyxPQUFPLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0FBQUEsSUFDbEMsR0FBRyxJQUFJO0FBQUEsRUFDVCxXQUFXLFNBQVM7QUFDbEIsV0FBTyxvQkFBb0IsT0FBTyxFQUFFLFFBQVEsU0FBUyxNQUFNO0FBQ3pELFdBQUssT0FBTyxNQUFNLFFBQVEsSUFBSSxDQUFDO0FBQUEsSUFDakMsR0FBRyxJQUFJO0FBQUEsRUFDVDtBQUNGO0FBRUFBLFNBQVEsVUFBVSxTQUFTLFNBQVMsTUFBTSxPQUFPO0FBQy9DLFNBQU8sY0FBYyxJQUFJO0FBQ3pCLFVBQVEsZUFBZSxLQUFLO0FBQzVCLE1BQUksV0FBVyxLQUFLLElBQUksSUFBSTtBQUM1QixPQUFLLElBQUksSUFBSSxJQUFJLFdBQVcsV0FBVyxPQUFPLFFBQVE7QUFDeEQ7QUFFQUEsU0FBUSxVQUFVLFFBQVEsSUFBSSxTQUFTLE1BQU07QUFDM0MsU0FBTyxLQUFLLElBQUksY0FBYyxJQUFJLENBQUM7QUFDckM7QUFFQUEsU0FBUSxVQUFVLE1BQU0sU0FBUyxNQUFNO0FBQ3JDLFNBQU8sY0FBYyxJQUFJO0FBQ3pCLFNBQU8sS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJO0FBQzNDO0FBRUFBLFNBQVEsVUFBVSxNQUFNLFNBQVMsTUFBTTtBQUNyQyxTQUFPLEtBQUssSUFBSSxlQUFlLGNBQWMsSUFBSSxDQUFDO0FBQ3BEO0FBRUFBLFNBQVEsVUFBVSxNQUFNLFNBQVMsTUFBTSxPQUFPO0FBQzVDLE9BQUssSUFBSSxjQUFjLElBQUksQ0FBQyxJQUFJLGVBQWUsS0FBSztBQUN0RDtBQUVBQSxTQUFRLFVBQVUsVUFBVSxTQUFTLFVBQVUsU0FBUztBQUN0RCxXQUFTLFFBQVEsS0FBSyxLQUFLO0FBQ3pCLFFBQUksS0FBSyxJQUFJLGVBQWUsSUFBSSxHQUFHO0FBQ2pDLGVBQVMsS0FBSyxTQUFTLEtBQUssSUFBSSxJQUFJLEdBQUcsTUFBTSxJQUFJO0FBQUEsSUFDbkQ7QUFBQSxFQUNGO0FBQ0Y7QUFFQUEsU0FBUSxVQUFVLE9BQU8sV0FBVztBQUNsQyxNQUFJLFFBQVEsQ0FBQztBQUNiLE9BQUssUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUNqQyxVQUFNLEtBQUssSUFBSTtBQUFBLEVBQ2pCLENBQUM7QUFDRCxTQUFPLFlBQVksS0FBSztBQUMxQjtBQUVBQSxTQUFRLFVBQVUsU0FBUyxXQUFXO0FBQ3BDLE1BQUksUUFBUSxDQUFDO0FBQ2IsT0FBSyxRQUFRLFNBQVMsT0FBTztBQUMzQixVQUFNLEtBQUssS0FBSztBQUFBLEVBQ2xCLENBQUM7QUFDRCxTQUFPLFlBQVksS0FBSztBQUMxQjtBQUVBQSxTQUFRLFVBQVUsVUFBVSxXQUFXO0FBQ3JDLE1BQUksUUFBUSxDQUFDO0FBQ2IsT0FBSyxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ2pDLFVBQU0sS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDO0FBQUEsRUFDMUIsQ0FBQztBQUNELFNBQU8sWUFBWSxLQUFLO0FBQzFCO0FBRUEsSUFBSSxRQUFRLFVBQVU7QUFDcEIsRUFBQUEsU0FBUSxVQUFVLE9BQU8sUUFBUSxJQUFJQSxTQUFRLFVBQVU7QUFDekQ7QUFFQSxTQUFTLFNBQVMsTUFBTTtBQUN0QixNQUFJLEtBQUs7QUFBUztBQUNsQixNQUFJLEtBQUssVUFBVTtBQUNqQixXQUFPLFFBQVEsT0FBTyxJQUFJLFVBQVUsY0FBYyxDQUFDO0FBQUEsRUFDckQ7QUFDQSxPQUFLLFdBQVc7QUFDbEI7QUFFQSxTQUFTLGdCQUFnQixRQUFRO0FBQy9CLFNBQU8sSUFBSSxRQUFRLFNBQVNDLFVBQVMsUUFBUTtBQUMzQyxXQUFPLFNBQVMsV0FBVztBQUN6QixNQUFBQSxTQUFRLE9BQU8sTUFBTTtBQUFBLElBQ3ZCO0FBQ0EsV0FBTyxVQUFVLFdBQVc7QUFDMUIsYUFBTyxPQUFPLEtBQUs7QUFBQSxJQUNyQjtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBRUEsU0FBUyxzQkFBc0IsTUFBTTtBQUNuQyxNQUFJLFNBQVMsSUFBSSxXQUFXO0FBQzVCLE1BQUksVUFBVSxnQkFBZ0IsTUFBTTtBQUNwQyxTQUFPLGtCQUFrQixJQUFJO0FBQzdCLFNBQU87QUFDVDtBQUVBLFNBQVMsZUFBZSxNQUFNO0FBQzVCLE1BQUksU0FBUyxJQUFJLFdBQVc7QUFDNUIsTUFBSSxVQUFVLGdCQUFnQixNQUFNO0FBQ3BDLE1BQUksUUFBUSwyQkFBMkIsS0FBSyxLQUFLLElBQUk7QUFDckQsTUFBSSxXQUFXLFFBQVEsTUFBTSxDQUFDLElBQUk7QUFDbEMsU0FBTyxXQUFXLE1BQU0sUUFBUTtBQUNoQyxTQUFPO0FBQ1Q7QUFFQSxTQUFTLHNCQUFzQixLQUFLO0FBQ2xDLE1BQUksT0FBTyxJQUFJLFdBQVcsR0FBRztBQUM3QixNQUFJLFFBQVEsSUFBSSxNQUFNLEtBQUssTUFBTTtBQUVqQyxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLFVBQU0sQ0FBQyxJQUFJLE9BQU8sYUFBYSxLQUFLLENBQUMsQ0FBQztBQUFBLEVBQ3hDO0FBQ0EsU0FBTyxNQUFNLEtBQUssRUFBRTtBQUN0QjtBQUVBLFNBQVMsWUFBWSxLQUFLO0FBQ3hCLE1BQUksSUFBSSxPQUFPO0FBQ2IsV0FBTyxJQUFJLE1BQU0sQ0FBQztBQUFBLEVBQ3BCLE9BQU87QUFDTCxRQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksVUFBVTtBQUN4QyxTQUFLLElBQUksSUFBSSxXQUFXLEdBQUcsQ0FBQztBQUM1QixXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQ0Y7QUFFQSxTQUFTLE9BQU87QUFDZCxPQUFLLFdBQVc7QUFFaEIsT0FBSyxZQUFZLFNBQVMsTUFBTTtBQVk5QixTQUFLLFdBQVcsS0FBSztBQUNyQixTQUFLLFlBQVk7QUFDakIsUUFBSSxDQUFDLE1BQU07QUFDVCxXQUFLLFVBQVU7QUFDZixXQUFLLFlBQVk7QUFBQSxJQUNuQixXQUFXLE9BQU8sU0FBUyxVQUFVO0FBQ25DLFdBQUssWUFBWTtBQUFBLElBQ25CLFdBQVcsUUFBUSxRQUFRLEtBQUssVUFBVSxjQUFjLElBQUksR0FBRztBQUM3RCxXQUFLLFlBQVk7QUFBQSxJQUNuQixXQUFXLFFBQVEsWUFBWSxTQUFTLFVBQVUsY0FBYyxJQUFJLEdBQUc7QUFDckUsV0FBSyxnQkFBZ0I7QUFBQSxJQUN2QixXQUFXLFFBQVEsZ0JBQWdCLGdCQUFnQixVQUFVLGNBQWMsSUFBSSxHQUFHO0FBQ2hGLFdBQUssWUFBWSxLQUFLLFNBQVM7QUFBQSxJQUNqQyxXQUFXLFFBQVEsZUFBZSxRQUFRLFFBQVEsV0FBVyxJQUFJLEdBQUc7QUFDbEUsV0FBSyxtQkFBbUIsWUFBWSxLQUFLLE1BQU07QUFFL0MsV0FBSyxZQUFZLElBQUksS0FBSyxDQUFDLEtBQUssZ0JBQWdCLENBQUM7QUFBQSxJQUNuRCxXQUFXLFFBQVEsZ0JBQWdCLFlBQVksVUFBVSxjQUFjLElBQUksS0FBSyxrQkFBa0IsSUFBSSxJQUFJO0FBQ3hHLFdBQUssbUJBQW1CLFlBQVksSUFBSTtBQUFBLElBQzFDLE9BQU87QUFDTCxXQUFLLFlBQVksT0FBTyxPQUFPLFVBQVUsU0FBUyxLQUFLLElBQUk7QUFBQSxJQUM3RDtBQUVBLFFBQUksQ0FBQyxLQUFLLFFBQVEsSUFBSSxjQUFjLEdBQUc7QUFDckMsVUFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixhQUFLLFFBQVEsSUFBSSxnQkFBZ0IsMEJBQTBCO0FBQUEsTUFDN0QsV0FBVyxLQUFLLGFBQWEsS0FBSyxVQUFVLE1BQU07QUFDaEQsYUFBSyxRQUFRLElBQUksZ0JBQWdCLEtBQUssVUFBVSxJQUFJO0FBQUEsTUFDdEQsV0FBVyxRQUFRLGdCQUFnQixnQkFBZ0IsVUFBVSxjQUFjLElBQUksR0FBRztBQUNoRixhQUFLLFFBQVEsSUFBSSxnQkFBZ0IsaURBQWlEO0FBQUEsTUFDcEY7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE1BQUksUUFBUSxNQUFNO0FBQ2hCLFNBQUssT0FBTyxXQUFXO0FBQ3JCLFVBQUksV0FBVyxTQUFTLElBQUk7QUFDNUIsVUFBSSxVQUFVO0FBQ1osZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLEtBQUssV0FBVztBQUNsQixlQUFPLFFBQVEsUUFBUSxLQUFLLFNBQVM7QUFBQSxNQUN2QyxXQUFXLEtBQUssa0JBQWtCO0FBQ2hDLGVBQU8sUUFBUSxRQUFRLElBQUksS0FBSyxDQUFDLEtBQUssZ0JBQWdCLENBQUMsQ0FBQztBQUFBLE1BQzFELFdBQVcsS0FBSyxlQUFlO0FBQzdCLGNBQU0sSUFBSSxNQUFNLHNDQUFzQztBQUFBLE1BQ3hELE9BQU87QUFDTCxlQUFPLFFBQVEsUUFBUSxJQUFJLEtBQUssQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsTUFDbkQ7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLE9BQUssY0FBYyxXQUFXO0FBQzVCLFFBQUksS0FBSyxrQkFBa0I7QUFDekIsVUFBSSxhQUFhLFNBQVMsSUFBSTtBQUM5QixVQUFJLFlBQVk7QUFDZCxlQUFPO0FBQUEsTUFDVCxXQUFXLFlBQVksT0FBTyxLQUFLLGdCQUFnQixHQUFHO0FBQ3BELGVBQU8sUUFBUTtBQUFBLFVBQ2IsS0FBSyxpQkFBaUIsT0FBTztBQUFBLFlBQzNCLEtBQUssaUJBQWlCO0FBQUEsWUFDdEIsS0FBSyxpQkFBaUIsYUFBYSxLQUFLLGlCQUFpQjtBQUFBLFVBQzNEO0FBQUEsUUFDRjtBQUFBLE1BQ0YsT0FBTztBQUNMLGVBQU8sUUFBUSxRQUFRLEtBQUssZ0JBQWdCO0FBQUEsTUFDOUM7QUFBQSxJQUNGLFdBQVcsUUFBUSxNQUFNO0FBQ3ZCLGFBQU8sS0FBSyxLQUFLLEVBQUUsS0FBSyxxQkFBcUI7QUFBQSxJQUMvQyxPQUFPO0FBQ0wsWUFBTSxJQUFJLE1BQU0sK0JBQStCO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBRUEsT0FBSyxPQUFPLFdBQVc7QUFDckIsUUFBSSxXQUFXLFNBQVMsSUFBSTtBQUM1QixRQUFJLFVBQVU7QUFDWixhQUFPO0FBQUEsSUFDVDtBQUVBLFFBQUksS0FBSyxXQUFXO0FBQ2xCLGFBQU8sZUFBZSxLQUFLLFNBQVM7QUFBQSxJQUN0QyxXQUFXLEtBQUssa0JBQWtCO0FBQ2hDLGFBQU8sUUFBUSxRQUFRLHNCQUFzQixLQUFLLGdCQUFnQixDQUFDO0FBQUEsSUFDckUsV0FBVyxLQUFLLGVBQWU7QUFDN0IsWUFBTSxJQUFJLE1BQU0sc0NBQXNDO0FBQUEsSUFDeEQsT0FBTztBQUNMLGFBQU8sUUFBUSxRQUFRLEtBQUssU0FBUztBQUFBLElBQ3ZDO0FBQUEsRUFDRjtBQUVBLE1BQUksUUFBUSxVQUFVO0FBQ3BCLFNBQUssV0FBVyxXQUFXO0FBQ3pCLGFBQU8sS0FBSyxLQUFLLEVBQUUsS0FBSyxNQUFNO0FBQUEsSUFDaEM7QUFBQSxFQUNGO0FBRUEsT0FBSyxPQUFPLFdBQVc7QUFDckIsV0FBTyxLQUFLLEtBQUssRUFBRSxLQUFLLEtBQUssS0FBSztBQUFBLEVBQ3BDO0FBRUEsU0FBTztBQUNUO0FBR0EsSUFBSSxVQUFVLENBQUMsV0FBVyxVQUFVLE9BQU8sUUFBUSxXQUFXLFNBQVMsUUFBUSxPQUFPLE9BQU87QUFFN0YsU0FBUyxnQkFBZ0IsUUFBUTtBQUMvQixNQUFJLFVBQVUsT0FBTyxZQUFZO0FBQ2pDLFNBQU8sUUFBUSxRQUFRLE9BQU8sSUFBSSxLQUFLLFVBQVU7QUFDbkQ7QUFFTyxTQUFTLFFBQVEsT0FBTyxTQUFTO0FBQ3RDLE1BQUksRUFBRSxnQkFBZ0IsVUFBVTtBQUM5QixVQUFNLElBQUksVUFBVSw0RkFBNEY7QUFBQSxFQUNsSDtBQUVBLFlBQVUsV0FBVyxDQUFDO0FBQ3RCLE1BQUksT0FBTyxRQUFRO0FBRW5CLE1BQUksaUJBQWlCLFNBQVM7QUFDNUIsUUFBSSxNQUFNLFVBQVU7QUFDbEIsWUFBTSxJQUFJLFVBQVUsY0FBYztBQUFBLElBQ3BDO0FBQ0EsU0FBSyxNQUFNLE1BQU07QUFDakIsU0FBSyxjQUFjLE1BQU07QUFDekIsUUFBSSxDQUFDLFFBQVEsU0FBUztBQUNwQixXQUFLLFVBQVUsSUFBSUQsU0FBUSxNQUFNLE9BQU87QUFBQSxJQUMxQztBQUNBLFNBQUssU0FBUyxNQUFNO0FBQ3BCLFNBQUssT0FBTyxNQUFNO0FBQ2xCLFNBQUssU0FBUyxNQUFNO0FBQ3BCLFFBQUksQ0FBQyxRQUFRLE1BQU0sYUFBYSxNQUFNO0FBQ3BDLGFBQU8sTUFBTTtBQUNiLFlBQU0sV0FBVztBQUFBLElBQ25CO0FBQUEsRUFDRixPQUFPO0FBQ0wsU0FBSyxNQUFNLE9BQU8sS0FBSztBQUFBLEVBQ3pCO0FBRUEsT0FBSyxjQUFjLFFBQVEsZUFBZSxLQUFLLGVBQWU7QUFDOUQsTUFBSSxRQUFRLFdBQVcsQ0FBQyxLQUFLLFNBQVM7QUFDcEMsU0FBSyxVQUFVLElBQUlBLFNBQVEsUUFBUSxPQUFPO0FBQUEsRUFDNUM7QUFDQSxPQUFLLFNBQVMsZ0JBQWdCLFFBQVEsVUFBVSxLQUFLLFVBQVUsS0FBSztBQUNwRSxPQUFLLE9BQU8sUUFBUSxRQUFRLEtBQUssUUFBUTtBQUN6QyxPQUFLLFNBQVMsUUFBUSxVQUFVLEtBQUssVUFBVyxXQUFZO0FBQzFELFFBQUkscUJBQXFCLEdBQUc7QUFDMUIsVUFBSSxPQUFPLElBQUksZ0JBQWdCO0FBQy9CLGFBQU8sS0FBSztBQUFBLElBQ2Q7QUFBQSxFQUNGLEVBQUU7QUFDRixPQUFLLFdBQVc7QUFFaEIsT0FBSyxLQUFLLFdBQVcsU0FBUyxLQUFLLFdBQVcsV0FBVyxNQUFNO0FBQzdELFVBQU0sSUFBSSxVQUFVLDJDQUEyQztBQUFBLEVBQ2pFO0FBQ0EsT0FBSyxVQUFVLElBQUk7QUFFbkIsTUFBSSxLQUFLLFdBQVcsU0FBUyxLQUFLLFdBQVcsUUFBUTtBQUNuRCxRQUFJLFFBQVEsVUFBVSxjQUFjLFFBQVEsVUFBVSxZQUFZO0FBRWhFLFVBQUksZ0JBQWdCO0FBQ3BCLFVBQUksY0FBYyxLQUFLLEtBQUssR0FBRyxHQUFHO0FBRWhDLGFBQUssTUFBTSxLQUFLLElBQUksUUFBUSxlQUFlLFNBQVMsSUFBSSxLQUFLLEVBQUUsUUFBUSxDQUFDO0FBQUEsTUFDMUUsT0FBTztBQUVMLFlBQUksZ0JBQWdCO0FBQ3BCLGFBQUssUUFBUSxjQUFjLEtBQUssS0FBSyxHQUFHLElBQUksTUFBTSxPQUFPLE9BQU8sSUFBSSxLQUFLLEVBQUUsUUFBUTtBQUFBLE1BQ3JGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQUVBLFFBQVEsVUFBVSxRQUFRLFdBQVc7QUFDbkMsU0FBTyxJQUFJLFFBQVEsTUFBTSxFQUFDLE1BQU0sS0FBSyxVQUFTLENBQUM7QUFDakQ7QUFFQSxTQUFTLE9BQU8sTUFBTTtBQUNwQixNQUFJLE9BQU8sSUFBSSxTQUFTO0FBQ3hCLE9BQ0csS0FBSyxFQUNMLE1BQU0sR0FBRyxFQUNULFFBQVEsU0FBUyxPQUFPO0FBQ3ZCLFFBQUksT0FBTztBQUNULFVBQUksUUFBUSxNQUFNLE1BQU0sR0FBRztBQUMzQixVQUFJLE9BQU8sTUFBTSxNQUFNLEVBQUUsUUFBUSxPQUFPLEdBQUc7QUFDM0MsVUFBSSxRQUFRLE1BQU0sS0FBSyxHQUFHLEVBQUUsUUFBUSxPQUFPLEdBQUc7QUFDOUMsV0FBSyxPQUFPLG1CQUFtQixJQUFJLEdBQUcsbUJBQW1CLEtBQUssQ0FBQztBQUFBLElBQ2pFO0FBQUEsRUFDRixDQUFDO0FBQ0gsU0FBTztBQUNUO0FBRUEsU0FBUyxhQUFhLFlBQVk7QUFDaEMsTUFBSSxVQUFVLElBQUlBLFNBQVE7QUFHMUIsTUFBSSxzQkFBc0IsV0FBVyxRQUFRLGdCQUFnQixHQUFHO0FBSWhFLHNCQUNHLE1BQU0sSUFBSSxFQUNWLElBQUksU0FBUyxRQUFRO0FBQ3BCLFdBQU8sT0FBTyxRQUFRLElBQUksTUFBTSxJQUFJLE9BQU8sT0FBTyxHQUFHLE9BQU8sTUFBTSxJQUFJO0FBQUEsRUFDeEUsQ0FBQyxFQUNBLFFBQVEsU0FBUyxNQUFNO0FBQ3RCLFFBQUksUUFBUSxLQUFLLE1BQU0sR0FBRztBQUMxQixRQUFJLE1BQU0sTUFBTSxNQUFNLEVBQUUsS0FBSztBQUM3QixRQUFJLEtBQUs7QUFDUCxVQUFJLFFBQVEsTUFBTSxLQUFLLEdBQUcsRUFBRSxLQUFLO0FBQ2pDLFVBQUk7QUFDRixnQkFBUSxPQUFPLEtBQUssS0FBSztBQUFBLE1BQzNCLFNBQVMsT0FBUDtBQUNBLGdCQUFRLEtBQUssY0FBYyxNQUFNLE9BQU87QUFBQSxNQUMxQztBQUFBLElBQ0Y7QUFBQSxFQUNGLENBQUM7QUFDSCxTQUFPO0FBQ1Q7QUFFQSxLQUFLLEtBQUssUUFBUSxTQUFTO0FBRXBCLFNBQVMsU0FBUyxVQUFVLFNBQVM7QUFDMUMsTUFBSSxFQUFFLGdCQUFnQixXQUFXO0FBQy9CLFVBQU0sSUFBSSxVQUFVLDRGQUE0RjtBQUFBLEVBQ2xIO0FBQ0EsTUFBSSxDQUFDLFNBQVM7QUFDWixjQUFVLENBQUM7QUFBQSxFQUNiO0FBRUEsT0FBSyxPQUFPO0FBQ1osT0FBSyxTQUFTLFFBQVEsV0FBVyxTQUFZLE1BQU0sUUFBUTtBQUMzRCxNQUFJLEtBQUssU0FBUyxPQUFPLEtBQUssU0FBUyxLQUFLO0FBQzFDLFVBQU0sSUFBSSxXQUFXLDBGQUEwRjtBQUFBLEVBQ2pIO0FBQ0EsT0FBSyxLQUFLLEtBQUssVUFBVSxPQUFPLEtBQUssU0FBUztBQUM5QyxPQUFLLGFBQWEsUUFBUSxlQUFlLFNBQVksS0FBSyxLQUFLLFFBQVE7QUFDdkUsT0FBSyxVQUFVLElBQUlBLFNBQVEsUUFBUSxPQUFPO0FBQzFDLE9BQUssTUFBTSxRQUFRLE9BQU87QUFDMUIsT0FBSyxVQUFVLFFBQVE7QUFDekI7QUFFQSxLQUFLLEtBQUssU0FBUyxTQUFTO0FBRTVCLFNBQVMsVUFBVSxRQUFRLFdBQVc7QUFDcEMsU0FBTyxJQUFJLFNBQVMsS0FBSyxXQUFXO0FBQUEsSUFDbEMsUUFBUSxLQUFLO0FBQUEsSUFDYixZQUFZLEtBQUs7QUFBQSxJQUNqQixTQUFTLElBQUlBLFNBQVEsS0FBSyxPQUFPO0FBQUEsSUFDakMsS0FBSyxLQUFLO0FBQUEsRUFDWixDQUFDO0FBQ0g7QUFFQSxTQUFTLFFBQVEsV0FBVztBQUMxQixNQUFJLFdBQVcsSUFBSSxTQUFTLE1BQU0sRUFBQyxRQUFRLEtBQUssWUFBWSxHQUFFLENBQUM7QUFDL0QsV0FBUyxLQUFLO0FBQ2QsV0FBUyxTQUFTO0FBQ2xCLFdBQVMsT0FBTztBQUNoQixTQUFPO0FBQ1Q7QUFFQSxJQUFJLG1CQUFtQixDQUFDLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRztBQUUvQyxTQUFTLFdBQVcsU0FBUyxLQUFLLFFBQVE7QUFDeEMsTUFBSSxpQkFBaUIsUUFBUSxNQUFNLE1BQU0sSUFBSTtBQUMzQyxVQUFNLElBQUksV0FBVyxxQkFBcUI7QUFBQSxFQUM1QztBQUVBLFNBQU8sSUFBSSxTQUFTLE1BQU0sRUFBQyxRQUFnQixTQUFTLEVBQUMsVUFBVSxJQUFHLEVBQUMsQ0FBQztBQUN0RTtBQUVPLElBQUksZUFBZSxFQUFFO0FBQzVCLElBQUk7QUFDRixNQUFJLGFBQWE7QUFDbkIsU0FBUyxLQUFQO0FBQ0EsaUJBQWUsU0FBUyxTQUFTLE1BQU07QUFDckMsU0FBSyxVQUFVO0FBQ2YsU0FBSyxPQUFPO0FBQ1osUUFBSSxRQUFRLE1BQU0sT0FBTztBQUN6QixTQUFLLFFBQVEsTUFBTTtBQUFBLEVBQ3JCO0FBQ0EsZUFBYSxZQUFZLE9BQU8sT0FBTyxNQUFNLFNBQVM7QUFDdEQsZUFBYSxVQUFVLGNBQWM7QUFDdkM7QUFFTyxTQUFTRSxPQUFNLE9BQU8sTUFBTTtBQUNqQyxTQUFPLElBQUksUUFBUSxTQUFTRCxVQUFTLFFBQVE7QUFDM0MsUUFBSSxVQUFVLElBQUksUUFBUSxPQUFPLElBQUk7QUFFckMsUUFBSSxRQUFRLFVBQVUsUUFBUSxPQUFPLFNBQVM7QUFDNUMsYUFBTyxPQUFPLElBQUksYUFBYSxXQUFXLFlBQVksQ0FBQztBQUFBLElBQ3pEO0FBRUEsUUFBSSxNQUFNLElBQUksZUFBZTtBQUU3QixhQUFTLFdBQVc7QUFDbEIsVUFBSSxNQUFNO0FBQUEsSUFDWjtBQUVBLFFBQUksU0FBUyxXQUFXO0FBQ3RCLFVBQUksVUFBVTtBQUFBLFFBQ1osWUFBWSxJQUFJO0FBQUEsUUFDaEIsU0FBUyxhQUFhLElBQUksc0JBQXNCLEtBQUssRUFBRTtBQUFBLE1BQ3pEO0FBR0EsVUFBSSxRQUFRLElBQUksUUFBUSxTQUFTLE1BQU0sTUFBTSxJQUFJLFNBQVMsT0FBTyxJQUFJLFNBQVMsTUFBTTtBQUNsRixnQkFBUSxTQUFTO0FBQUEsTUFDbkIsT0FBTztBQUNMLGdCQUFRLFNBQVMsSUFBSTtBQUFBLE1BQ3ZCO0FBQ0EsY0FBUSxNQUFNLGlCQUFpQixNQUFNLElBQUksY0FBYyxRQUFRLFFBQVEsSUFBSSxlQUFlO0FBQzFGLFVBQUksT0FBTyxjQUFjLE1BQU0sSUFBSSxXQUFXLElBQUk7QUFDbEQsaUJBQVcsV0FBVztBQUNwQixRQUFBQSxTQUFRLElBQUksU0FBUyxNQUFNLE9BQU8sQ0FBQztBQUFBLE1BQ3JDLEdBQUcsQ0FBQztBQUFBLElBQ047QUFFQSxRQUFJLFVBQVUsV0FBVztBQUN2QixpQkFBVyxXQUFXO0FBQ3BCLGVBQU8sSUFBSSxVQUFVLHdCQUF3QixDQUFDO0FBQUEsTUFDaEQsR0FBRyxDQUFDO0FBQUEsSUFDTjtBQUVBLFFBQUksWUFBWSxXQUFXO0FBQ3pCLGlCQUFXLFdBQVc7QUFDcEIsZUFBTyxJQUFJLFVBQVUsMkJBQTJCLENBQUM7QUFBQSxNQUNuRCxHQUFHLENBQUM7QUFBQSxJQUNOO0FBRUEsUUFBSSxVQUFVLFdBQVc7QUFDdkIsaUJBQVcsV0FBVztBQUNwQixlQUFPLElBQUksYUFBYSxXQUFXLFlBQVksQ0FBQztBQUFBLE1BQ2xELEdBQUcsQ0FBQztBQUFBLElBQ047QUFFQSxhQUFTLE9BQU8sS0FBSztBQUNuQixVQUFJO0FBQ0YsZUFBTyxRQUFRLE1BQU0sRUFBRSxTQUFTLE9BQU8sRUFBRSxTQUFTLE9BQU87QUFBQSxNQUMzRCxTQUFTLEdBQVA7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFFQSxRQUFJLEtBQUssUUFBUSxRQUFRLE9BQU8sUUFBUSxHQUFHLEdBQUcsSUFBSTtBQUVsRCxRQUFJLFFBQVEsZ0JBQWdCLFdBQVc7QUFDckMsVUFBSSxrQkFBa0I7QUFBQSxJQUN4QixXQUFXLFFBQVEsZ0JBQWdCLFFBQVE7QUFDekMsVUFBSSxrQkFBa0I7QUFBQSxJQUN4QjtBQUVBLFFBQUksa0JBQWtCLEtBQUs7QUFDekIsVUFBSSxRQUFRLE1BQU07QUFDaEIsWUFBSSxlQUFlO0FBQUEsTUFDckIsV0FDRSxRQUFRLGFBQ1I7QUFDQSxZQUFJLGVBQWU7QUFBQSxNQUNyQjtBQUFBLElBQ0Y7QUFFQSxRQUFJLFFBQVEsT0FBTyxLQUFLLFlBQVksWUFBWSxFQUFFLEtBQUssbUJBQW1CRCxZQUFZLEVBQUUsV0FBVyxLQUFLLG1CQUFtQixFQUFFLFVBQVc7QUFDdEksVUFBSSxRQUFRLENBQUM7QUFDYixhQUFPLG9CQUFvQixLQUFLLE9BQU8sRUFBRSxRQUFRLFNBQVMsTUFBTTtBQUM5RCxjQUFNLEtBQUssY0FBYyxJQUFJLENBQUM7QUFDOUIsWUFBSSxpQkFBaUIsTUFBTSxlQUFlLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQztBQUFBLE1BQy9ELENBQUM7QUFDRCxjQUFRLFFBQVEsUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUM1QyxZQUFJLE1BQU0sUUFBUSxJQUFJLE1BQU0sSUFBSTtBQUM5QixjQUFJLGlCQUFpQixNQUFNLEtBQUs7QUFBQSxRQUNsQztBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0gsT0FBTztBQUNMLGNBQVEsUUFBUSxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQzVDLFlBQUksaUJBQWlCLE1BQU0sS0FBSztBQUFBLE1BQ2xDLENBQUM7QUFBQSxJQUNIO0FBRUEsUUFBSSxRQUFRLFFBQVE7QUFDbEIsY0FBUSxPQUFPLGlCQUFpQixTQUFTLFFBQVE7QUFFakQsVUFBSSxxQkFBcUIsV0FBVztBQUVsQyxZQUFJLElBQUksZUFBZSxHQUFHO0FBQ3hCLGtCQUFRLE9BQU8sb0JBQW9CLFNBQVMsUUFBUTtBQUFBLFFBQ3REO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxRQUFJLEtBQUssT0FBTyxRQUFRLGNBQWMsY0FBYyxPQUFPLFFBQVEsU0FBUztBQUFBLEVBQzlFLENBQUM7QUFDSDtBQUVBRSxPQUFNLFdBQVc7QUFFakIsSUFBSSxDQUFDLEVBQUUsT0FBTztBQUNaLElBQUUsUUFBUUE7QUFDVixJQUFFLFVBQVVGO0FBQ1osSUFBRSxVQUFVO0FBQ1osSUFBRSxXQUFXO0FBQ2Y7OztBQy9uQkEsSUFBTSxjQUFjO0FBQ3BCLElBQU0sY0FBYyxvQkFBb0I7QUFFeEMsSUFBTSxVQUFVO0FBRWhCLElBQUksY0FBYyxPQUFPO0FBQ3pCLElBQUksb0JBQW9CLENBQUMsS0FBSyxLQUFLLFVBQVUsT0FBTyxNQUFNLFlBQVksS0FBSyxLQUFLLEVBQUUsWUFBWSxNQUFNLGNBQWMsTUFBTSxVQUFVLE1BQU0sTUFBTSxDQUFDLElBQUksSUFBSSxHQUFHLElBQUk7QUFDOUosSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLEtBQUssVUFBVTtBQUN6QyxvQkFBa0IsS0FBSyxPQUFPLFFBQVEsV0FBVyxNQUFNLEtBQUssS0FBSyxLQUFLO0FBQ3RFLFNBQU87QUFDVDtBQUNBLElBQU0sZ0JBQU4sY0FBNEIsTUFBTTtBQUFBLEVBQ2hDLFlBQVksT0FBTyxhQUFhO0FBQzlCLFVBQU0sS0FBSztBQUNYLFNBQUssUUFBUTtBQUNiLFNBQUssY0FBYztBQUNuQixTQUFLLE9BQU87QUFDWixRQUFJLE1BQU0sbUJBQW1CO0FBQzNCLFlBQU0sa0JBQWtCLE1BQU0sYUFBYTtBQUFBLElBQzdDO0FBQUEsRUFDRjtBQUNGO0FBQ0EsSUFBTSx5QkFBTixNQUE2QjtBQUFBLEVBQzNCLFlBQVksaUJBQWlCLEtBQUssY0FBYztBQUM5QyxvQkFBZ0IsTUFBTSxpQkFBaUI7QUFDdkMsb0JBQWdCLE1BQU0sS0FBSztBQUMzQixvQkFBZ0IsTUFBTSxjQUFjO0FBQ3BDLFNBQUssa0JBQWtCO0FBQ3ZCLFNBQUssTUFBTTtBQUNYLFNBQUssZUFBZTtBQUFBLEVBQ3RCO0FBQUEsRUFDQSxRQUFRO0FBQ04sU0FBSyxnQkFBZ0IsTUFBTTtBQUFBLEVBQzdCO0FBQUEsRUFDQSxRQUFRLE9BQU8sYUFBYSxJQUFJO0FBQzlCLHFCQUFpQixXQUFXLEtBQUssS0FBSztBQUNwQyxVQUFJLFdBQVcsU0FBUztBQUN0QixjQUFNLElBQUksTUFBTSxRQUFRLEtBQUs7QUFBQSxNQUMvQjtBQUNBLFlBQU07QUFDTixVQUFJLFFBQVEsUUFBUSxRQUFRLFdBQVcsV0FBVztBQUNoRCxhQUFLLGFBQWE7QUFDbEI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFVBQU0sSUFBSSxNQUFNLHFEQUFxRDtBQUFBLEVBQ3ZFO0FBQ0Y7QUFDQSxJQUFNLFVBQVUsT0FBTyxhQUFhO0FBbERwQztBQW1ERSxNQUFJLFNBQVMsSUFBSTtBQUNmO0FBQUEsRUFDRjtBQUNBLE1BQUksVUFBVSxTQUFTLFNBQVMsV0FBVyxTQUFTO0FBQ3BELE1BQUksWUFBWTtBQUNoQixPQUFJLGNBQVMsUUFBUSxJQUFJLGNBQWMsTUFBbkMsbUJBQXNDLFNBQVMscUJBQXFCO0FBQ3RFLFFBQUk7QUFDRixrQkFBWSxNQUFNLFNBQVMsS0FBSztBQUNoQyxnQkFBVSxVQUFVLFNBQVM7QUFBQSxJQUMvQixTQUFTLE9BQVA7QUFDQSxjQUFRLElBQUksd0NBQXdDO0FBQUEsSUFDdEQ7QUFBQSxFQUNGLE9BQU87QUFDTCxRQUFJO0FBQ0YsY0FBUSxJQUFJLDRCQUE0QjtBQUN4QyxZQUFNLGVBQWUsTUFBTSxTQUFTLEtBQUs7QUFDekMsZ0JBQVUsZ0JBQWdCO0FBQUEsSUFDNUIsU0FBUyxPQUFQO0FBQ0EsY0FBUSxJQUFJLHdDQUF3QztBQUFBLElBQ3REO0FBQUEsRUFDRjtBQUNBLFFBQU0sSUFBSSxjQUFjLFNBQVMsU0FBUyxNQUFNO0FBQ2xEO0FBQ0EsU0FBUyxjQUFjO0FBMUV2QjtBQTJFRSxNQUFJLE9BQU8sV0FBVyxlQUFlLE9BQU8sV0FBVztBQUNyRCxVQUFNLE1BQU07QUFDWixRQUFJLG1CQUFtQixTQUFPLFNBQUksa0JBQUosbUJBQW1CLFdBQVU7QUFDekQsYUFBTyxHQUFHLElBQUksY0FBYyxTQUFTLFlBQVksYUFBYSxVQUFVO0FBQUEsSUFDMUU7QUFDQSxRQUFJLFVBQVUsVUFBVTtBQUN0QixhQUFPLEdBQUcsVUFBVSxTQUFTLFlBQVksYUFBYSxVQUFVO0FBQUEsSUFDbEU7QUFDQSxXQUFPLG1CQUFtQixVQUFVO0FBQUEsRUFDdEMsV0FBVyxPQUFPLFlBQVksYUFBYTtBQUN6QyxXQUFPLEdBQUcsUUFBUSxRQUFRLFFBQVEsb0JBQW9CLFFBQVE7QUFBQSxFQUNoRTtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsaUJBQWlCLFNBQVM7QUFDakMsTUFBSSxtQkFBbUIsU0FBUztBQUM5QixVQUFNLE1BQU0sQ0FBQztBQUNiLFlBQVEsUUFBUSxDQUFDLE9BQU8sUUFBUTtBQUM5QixVQUFJLEdBQUcsSUFBSTtBQUFBLElBQ2IsQ0FBQztBQUNELFdBQU87QUFBQSxFQUNULFdBQVcsTUFBTSxRQUFRLE9BQU8sR0FBRztBQUNqQyxXQUFPLE9BQU8sWUFBWSxPQUFPO0FBQUEsRUFDbkMsT0FBTztBQUNMLFdBQU8sV0FBVyxDQUFDO0FBQUEsRUFDckI7QUFDRjtBQUNBLElBQU0sbUJBQW1CLE9BQU9HLFFBQU8sS0FBSyxVQUFVLENBQUMsTUFBTTtBQUMzRCxRQUFNLGlCQUFpQjtBQUFBLElBQ3JCLGdCQUFnQjtBQUFBLElBQ2hCLFFBQVE7QUFBQSxJQUNSLGNBQWMsYUFBYSxZQUFZLFlBQVk7QUFBQSxFQUNyRDtBQUNBLFVBQVEsVUFBVSxpQkFBaUIsUUFBUSxPQUFPO0FBQ2xELFFBQU0sZ0JBQWdCLE9BQU87QUFBQSxJQUMzQixPQUFPLFFBQVEsUUFBUSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxLQUFLLGNBQWMsRUFBRSxLQUFLLENBQUMsZUFBZSxXQUFXLFlBQVksTUFBTSxJQUFJLFlBQVksQ0FBQyxDQUFDO0FBQUEsRUFDcko7QUFDQSxVQUFRLFVBQVU7QUFBQSxJQUNoQixHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsRUFDTDtBQUNBLFNBQU9BLE9BQU0sS0FBSyxPQUFPO0FBQzNCO0FBQ0EsSUFBTSxNQUFNLE9BQU9BLFFBQU8sTUFBTSxZQUFZO0FBQzFDLFFBQU0sV0FBVyxNQUFNLGlCQUFpQkEsUUFBTyxNQUFNO0FBQUEsSUFDbkQsU0FBUyxtQ0FBUztBQUFBLEVBQ3BCLENBQUM7QUFDRCxRQUFNLFFBQVEsUUFBUTtBQUN0QixTQUFPO0FBQ1Q7QUFDQSxJQUFNLE9BQU8sT0FBT0EsUUFBTyxNQUFNLE1BQU0sWUFBWTtBQUNqRCxRQUFNLFdBQVcsQ0FBQyxVQUFVO0FBQzFCLFdBQU8sVUFBVSxRQUFRLE9BQU8sVUFBVSxZQUFZLENBQUMsTUFBTSxRQUFRLEtBQUs7QUFBQSxFQUM1RTtBQUNBLFFBQU0sZ0JBQWdCLFNBQVMsSUFBSSxJQUFJLEtBQUssVUFBVSxJQUFJLElBQUk7QUFDOUQsUUFBTSxXQUFXLE1BQU0saUJBQWlCQSxRQUFPLE1BQU07QUFBQSxJQUNuRCxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixRQUFRLG1DQUFTO0FBQUEsSUFDakIsU0FBUyxtQ0FBUztBQUFBLEVBQ3BCLENBQUM7QUFDRCxRQUFNLFFBQVEsUUFBUTtBQUN0QixTQUFPO0FBQ1Q7QUFDQSxJQUFNLE1BQU0sT0FBT0EsUUFBTyxNQUFNLE1BQU0sWUFBWTtBQUNoRCxRQUFNLFdBQVcsTUFBTSxpQkFBaUJBLFFBQU8sTUFBTTtBQUFBLElBQ25ELFFBQVE7QUFBQSxJQUNSLE1BQU0sS0FBSyxVQUFVLElBQUk7QUFBQSxJQUN6QixTQUFTLG1DQUFTO0FBQUEsRUFDcEIsQ0FBQztBQUNELFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFNBQU87QUFDVDtBQUNBLElBQU0sWUFBWSxpQkFBaUIsS0FBSztBQXBKeEM7QUFxSkUsUUFBTSxVQUFVLElBQUksWUFBWSxPQUFPO0FBQ3ZDLE1BQUksU0FBUztBQUNiLFFBQU0sU0FBUyxJQUFJLFVBQVU7QUFDN0IsU0FBTyxNQUFNO0FBQ1gsVUFBTSxFQUFFLE1BQU0sT0FBTyxNQUFNLElBQUksTUFBTSxPQUFPLEtBQUs7QUFDakQsUUFBSSxNQUFNO0FBQ1I7QUFBQSxJQUNGO0FBQ0EsY0FBVSxRQUFRLE9BQU8sS0FBSztBQUM5QixVQUFNLFFBQVEsT0FBTyxNQUFNLElBQUk7QUFDL0IsY0FBUyxXQUFNLElBQUksTUFBVixZQUFlO0FBQ3hCLGVBQVcsUUFBUSxPQUFPO0FBQ3hCLFVBQUk7QUFDRixjQUFNLEtBQUssTUFBTSxJQUFJO0FBQUEsTUFDdkIsU0FBUyxPQUFQO0FBQ0EsZ0JBQVEsS0FBSyxrQkFBa0IsSUFBSTtBQUFBLE1BQ3JDO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxhQUFXLFFBQVEsT0FBTyxNQUFNLElBQUksRUFBRSxPQUFPLENBQUMsTUFBTSxNQUFNLEVBQUUsR0FBRztBQUM3RCxRQUFJO0FBQ0YsWUFBTSxLQUFLLE1BQU0sSUFBSTtBQUFBLElBQ3ZCLFNBQVMsT0FBUDtBQUNBLGNBQVEsS0FBSyxrQkFBa0IsSUFBSTtBQUFBLElBQ3JDO0FBQUEsRUFDRjtBQUNGO0FBQ0EsSUFBTSxhQUFhLENBQUMsU0FBUztBQUMzQixNQUFJLENBQUMsTUFBTTtBQUNULFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxxQkFBcUIsS0FBSyxTQUFTLEtBQUs7QUFDNUMsTUFBSSxLQUFLLFdBQVcsR0FBRyxHQUFHO0FBQ3hCLFdBQU8sbUJBQW1CO0FBQzFCLHlCQUFxQjtBQUFBLEVBQ3ZCO0FBQ0EsTUFBSSxDQUFDLG9CQUFvQjtBQUN2QixXQUFPLFVBQVU7QUFBQSxFQUNuQjtBQUNBLFFBQU0sTUFBTSxJQUFJLElBQUksSUFBSTtBQUN4QixNQUFJLE9BQU8sSUFBSTtBQUNmLE1BQUksQ0FBQyxNQUFNO0FBQ1QsUUFBSSxDQUFDLG9CQUFvQjtBQUN2QixhQUFPO0FBQUEsSUFDVCxPQUFPO0FBQ0wsYUFBTyxJQUFJLGFBQWEsV0FBVyxRQUFRO0FBQUEsSUFDN0M7QUFBQSxFQUNGO0FBQ0EsTUFBSSxPQUFPO0FBQ1gsTUFBSSxJQUFJLFVBQVU7QUFDaEIsV0FBTyxJQUFJO0FBQ1gsUUFBSSxJQUFJLFVBQVU7QUFDaEIsY0FBUSxJQUFJLElBQUk7QUFBQSxJQUNsQjtBQUNBLFlBQVE7QUFBQSxFQUNWO0FBQ0EsTUFBSSxnQkFBZ0IsR0FBRyxJQUFJLGFBQWEsT0FBTyxJQUFJLFlBQVksT0FBTyxJQUFJO0FBQzFFLE1BQUksY0FBYyxTQUFTLEdBQUcsR0FBRztBQUMvQixvQkFBZ0IsY0FBYyxNQUFNLEdBQUcsRUFBRTtBQUFBLEVBQzNDO0FBQ0EsU0FBTztBQUNUO0FBRUEsSUFBSUMsYUFBWSxPQUFPO0FBQ3ZCLElBQUksa0JBQWtCLENBQUMsS0FBSyxLQUFLLFVBQVUsT0FBTyxNQUFNQSxXQUFVLEtBQUssS0FBSyxFQUFFLFlBQVksTUFBTSxjQUFjLE1BQU0sVUFBVSxNQUFNLE1BQU0sQ0FBQyxJQUFJLElBQUksR0FBRyxJQUFJO0FBQzFKLElBQUksZ0JBQWdCLENBQUMsS0FBSyxLQUFLLFVBQVU7QUFDdkMsa0JBQWdCLEtBQUssT0FBTyxRQUFRLFdBQVcsTUFBTSxLQUFLLEtBQUssS0FBSztBQUNwRSxTQUFPO0FBQ1Q7QUFDQSxJQUFJLFdBQVcsTUFBTSxPQUFPO0FBQUEsRUFDMUIsWUFBWSxRQUFRO0FBM050QjtBQTROSSxrQkFBYyxNQUFNLFFBQVE7QUFDNUIsa0JBQWMsTUFBTSxPQUFPO0FBQzNCLGtCQUFjLE1BQU0sMkJBQTJCLENBQUMsQ0FBQztBQUNqRCxTQUFLLFNBQVM7QUFBQSxNQUNaLE1BQU07QUFBQSxNQUNOLFNBQVMsaUNBQVE7QUFBQSxJQUNuQjtBQUNBLFFBQUksRUFBQyxpQ0FBUSxRQUFPO0FBQ2xCLFdBQUssT0FBTyxPQUFPLFlBQVcsc0NBQVEsU0FBUixZQUFnQixXQUFXO0FBQUEsSUFDM0Q7QUFDQSxTQUFLLFNBQVEsc0NBQVEsVUFBUixZQUFpQjtBQUFBLEVBQ2hDO0FBQUE7QUFBQSxFQUVBLFFBQVE7QUFDTixlQUFXLFdBQVcsS0FBSyx5QkFBeUI7QUFDbEQsY0FBUSxNQUFNO0FBQUEsSUFDaEI7QUFDQSxTQUFLLHdCQUF3QixTQUFTO0FBQUEsRUFDeEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFZQSxNQUFNLHlCQUF5QixVQUFVLFNBQVM7QUExUHBEO0FBMlBJLFlBQVEsVUFBUyxhQUFRLFdBQVIsWUFBa0I7QUFDbkMsVUFBTSxPQUFPLEdBQUcsS0FBSyxPQUFPLFlBQVk7QUFDeEMsUUFBSSxRQUFRLFFBQVE7QUFDbEIsWUFBTSxrQkFBa0IsSUFBSSxnQkFBZ0I7QUFDNUMsWUFBTSxZQUFZLE1BQU0sS0FBSyxLQUFLLE9BQU8sTUFBTSxTQUFTO0FBQUEsUUFDdEQsUUFBUSxnQkFBZ0I7QUFBQSxRQUN4QixTQUFTLEtBQUssT0FBTztBQUFBLE1BQ3ZCLENBQUM7QUFDRCxVQUFJLENBQUMsVUFBVSxNQUFNO0FBQ25CLGNBQU0sSUFBSSxNQUFNLGNBQWM7QUFBQSxNQUNoQztBQUNBLFlBQU0sTUFBTSxVQUFVLFVBQVUsSUFBSTtBQUNwQyxZQUFNLHlCQUF5QixJQUFJO0FBQUEsUUFDakM7QUFBQSxRQUNBO0FBQUEsUUFDQSxNQUFNO0FBQ0osZ0JBQU0sSUFBSSxLQUFLLHdCQUF3QixRQUFRLHNCQUFzQjtBQUNyRSxjQUFJLElBQUksSUFBSTtBQUNWLGlCQUFLLHdCQUF3QixPQUFPLEdBQUcsQ0FBQztBQUFBLFVBQzFDO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxXQUFLLHdCQUF3QixLQUFLLHNCQUFzQjtBQUN4RCxhQUFPO0FBQUEsSUFDVDtBQUNBLFVBQU0sV0FBVyxNQUFNLEtBQUssS0FBSyxPQUFPLE1BQU0sU0FBUztBQUFBLE1BQ3JELFNBQVMsS0FBSyxPQUFPO0FBQUEsSUFDdkIsQ0FBQztBQUNELFdBQU8sTUFBTSxTQUFTLEtBQUs7QUFBQSxFQUM3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1BLE1BQU0sWUFBWSxPQUFPO0FBQ3ZCLFFBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0IsWUFBTSxhQUFhLElBQUksV0FBVyxLQUFLO0FBQ3ZDLFVBQUksYUFBYTtBQUNqQixZQUFNLE1BQU0sV0FBVztBQUN2QixlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSztBQUM1QixzQkFBYyxPQUFPLGFBQWEsV0FBVyxDQUFDLENBQUM7QUFBQSxNQUNqRDtBQUNBLGFBQU8sS0FBSyxVQUFVO0FBQUEsSUFDeEI7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsTUFBTSxTQUFTLFNBQVM7QUFDdEIsUUFBSSxRQUFRLFFBQVE7QUFDbEIsY0FBUSxTQUFTLE1BQU0sUUFBUSxJQUFJLFFBQVEsT0FBTyxJQUFJLEtBQUssWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQUEsSUFDcEY7QUFDQSxXQUFPLEtBQUsseUJBQXlCLFlBQVksT0FBTztBQUFBLEVBQzFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBU0EsTUFBTSxLQUFLLFNBQVM7QUFDbEIsUUFBSSxRQUFRLFVBQVU7QUFDcEIsaUJBQVcsV0FBVyxRQUFRLFVBQVU7QUFDdEMsWUFBSSxRQUFRLFFBQVE7QUFDbEIsa0JBQVEsU0FBUyxNQUFNLFFBQVE7QUFBQSxZQUM3QixRQUFRLE9BQU8sSUFBSSxLQUFLLFlBQVksS0FBSyxJQUFJLENBQUM7QUFBQSxVQUNoRDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFdBQU8sS0FBSyx5QkFBeUIsUUFBUSxPQUFPO0FBQUEsRUFDdEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLE9BQU8sU0FBUztBQUNwQixXQUFPLEtBQUsseUJBQXlCLFVBQVU7QUFBQSxNQUM3QyxHQUFHO0FBQUEsSUFDTCxDQUFDO0FBQUEsRUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFRQSxNQUFNLEtBQUssU0FBUztBQUNsQixXQUFPLEtBQUsseUJBQXlCLFFBQVE7QUFBQSxNQUMzQyxNQUFNLFFBQVE7QUFBQSxNQUNkLFFBQVEsUUFBUTtBQUFBLE1BQ2hCLFVBQVUsUUFBUTtBQUFBLElBQ3BCLENBQUM7QUFBQSxFQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVFBLE1BQU0sS0FBSyxTQUFTO0FBQ2xCLFdBQU8sS0FBSyx5QkFBeUIsUUFBUTtBQUFBLE1BQzNDLE1BQU0sUUFBUTtBQUFBLE1BQ2QsUUFBUSxRQUFRO0FBQUEsTUFDaEIsVUFBVSxRQUFRO0FBQUEsSUFDcEIsQ0FBQztBQUFBLEVBQ0g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLE1BQU0sT0FBTyxTQUFTO0FBQ3BCLFVBQU07QUFBQSxNQUNKLEtBQUs7QUFBQSxNQUNMLEdBQUcsS0FBSyxPQUFPO0FBQUEsTUFDZixFQUFFLE1BQU0sUUFBUSxNQUFNO0FBQUEsTUFDdEIsRUFBRSxTQUFTLEtBQUssT0FBTyxRQUFRO0FBQUEsSUFDakM7QUFDQSxXQUFPLEVBQUUsUUFBUSxVQUFVO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLE1BQU0sS0FBSyxTQUFTO0FBQ2xCLFVBQU0sS0FBSyxLQUFLLE9BQU8sR0FBRyxLQUFLLE9BQU8saUJBQWlCLEVBQUUsR0FBRyxRQUFRLEdBQUc7QUFBQSxNQUNyRSxTQUFTLEtBQUssT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFDRCxXQUFPLEVBQUUsUUFBUSxVQUFVO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLE9BQU87QUFDWCxVQUFNLFdBQVcsTUFBTSxJQUFJLEtBQUssT0FBTyxHQUFHLEtBQUssT0FBTyxpQkFBaUI7QUFBQSxNQUNyRSxTQUFTLEtBQUssT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFDRCxXQUFPLE1BQU0sU0FBUyxLQUFLO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLEtBQUssU0FBUztBQUNsQixVQUFNLFdBQVcsTUFBTSxLQUFLLEtBQUssT0FBTyxHQUFHLEtBQUssT0FBTyxpQkFBaUI7QUFBQSxNQUN0RSxHQUFHO0FBQUEsSUFDTCxHQUFHO0FBQUEsTUFDRCxTQUFTLEtBQUssT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFDRCxXQUFPLE1BQU0sU0FBUyxLQUFLO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLE1BQU0sU0FBUztBQUNuQixVQUFNLFdBQVcsTUFBTSxLQUFLLEtBQUssT0FBTyxHQUFHLEtBQUssT0FBTyxrQkFBa0I7QUFBQSxNQUN2RSxHQUFHO0FBQUEsSUFDTCxHQUFHO0FBQUEsTUFDRCxTQUFTLEtBQUssT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFDRCxXQUFPLE1BQU0sU0FBUyxLQUFLO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLFdBQVcsU0FBUztBQUN4QixVQUFNLFdBQVcsTUFBTSxLQUFLLEtBQUssT0FBTyxHQUFHLEtBQUssT0FBTyx1QkFBdUI7QUFBQSxNQUM1RSxHQUFHO0FBQUEsSUFDTCxHQUFHO0FBQUEsTUFDRCxTQUFTLEtBQUssT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFDRCxXQUFPLE1BQU0sU0FBUyxLQUFLO0FBQUEsRUFDN0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLEtBQUs7QUFDVCxVQUFNLFdBQVcsTUFBTSxJQUFJLEtBQUssT0FBTyxHQUFHLEtBQUssT0FBTyxlQUFlO0FBQUEsTUFDbkUsU0FBUyxLQUFLLE9BQU87QUFBQSxJQUN2QixDQUFDO0FBQ0QsV0FBTyxNQUFNLFNBQVMsS0FBSztBQUFBLEVBQzdCO0FBQ0Y7QUFDQSxJQUFNLFVBQVUsSUFBSSxTQUFTOzs7QUZwYzdCLElBQU1DLFVBQU4sY0FBcUIsU0FBUztBQUFBLEVBQzVCLE1BQU0sWUFBWSxPQUFPO0FBQ3ZCLFFBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0IsYUFBTyxPQUFPLEtBQUssS0FBSyxFQUFFLFNBQVMsUUFBUTtBQUFBLElBQzdDO0FBQ0EsUUFBSTtBQUNGLFVBQUksVUFBQUMsUUFBRyxXQUFXLEtBQUssR0FBRztBQUN4QixjQUFNLGFBQWEsTUFBTSxtQkFBUyxhQUFTLHFCQUFRLEtBQUssQ0FBQztBQUN6RCxlQUFPLE9BQU8sS0FBSyxVQUFVLEVBQUUsU0FBUyxRQUFRO0FBQUEsTUFDbEQ7QUFBQSxJQUNGLFNBQVEsR0FBTjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsTUFBTSxXQUFXLE1BQU07QUFDckIsUUFBSTtBQUNGLFlBQU0sbUJBQVMsT0FBTyxJQUFJO0FBQzFCLGFBQU87QUFBQSxJQUNULFNBQVEsR0FBTjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBLEVBQ0EsTUFBTSxPQUFPLFNBQVM7QUFDcEIsUUFBSSxRQUFRLFFBQVEsTUFBTSxLQUFLLGVBQVcscUJBQVEsUUFBUSxJQUFJLENBQUMsR0FBRztBQUNoRSxZQUFNLE1BQU0sc0VBQXNFO0FBQUEsSUFDcEY7QUFDQSxRQUFJLFFBQVEsUUFBUTtBQUNsQixhQUFPLE1BQU0sT0FBTyxPQUFPO0FBQUEsSUFDN0IsT0FBTztBQUNMLGFBQU8sTUFBTSxPQUFPLE9BQU87QUFBQSxJQUM3QjtBQUFBLEVBQ0Y7QUFDRjtBQUNBLElBQU0sUUFBUSxJQUFJRCxRQUFPOzs7QURsQ3pCLElBQU0sbUJBQXFDO0FBQUEsRUFDMUMsV0FBVztBQUNaO0FBRUEsSUFBcUIsbUJBQXJCLGNBQThDLHVCQUFPO0FBQUEsRUFHcEQsTUFBTSxTQUFTO0FBQ2QsVUFBTSxLQUFLLGFBQWE7QUFHeEIsVUFBTSxlQUFlLEtBQUssY0FBYyxRQUFRLGlCQUFpQixDQUFDLFFBQW9CO0FBRXJGLFVBQUksdUJBQU8sbUJBQW1CO0FBQUEsSUFDL0IsQ0FBQztBQUVELGlCQUFhLFNBQVMsd0JBQXdCO0FBRzlDLFVBQU0sa0JBQWtCLEtBQUssaUJBQWlCO0FBQzlDLG9CQUFnQixRQUFRLGlCQUFpQjtBQUd6QyxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTTtBQUNmLFlBQUksWUFBWSxLQUFLLEdBQUcsRUFBRSxLQUFLO0FBQUEsTUFDaEM7QUFBQSxJQUNELENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLGdCQUFnQixDQUFDLFFBQWdCLFNBQXVCO0FBQ3ZELGdCQUFRLElBQUksT0FBTyxhQUFhLENBQUM7QUFDakMsZUFBTyxpQkFBaUIsdUJBQXVCO0FBQUEsTUFDaEQ7QUFBQSxJQUNELENBQUM7QUFFRCxTQUFLLGNBQWMsUUFBUSxTQUFTLFlBQVk7QUFDL0MsVUFBSTtBQUNKLGNBQU0sT0FBTyxNQUFNLE1BQU8sV0FBVyxFQUFFLE9BQU8sb0JBQW9CLFFBQVEsaURBQWlELENBQUM7QUFDNUgsWUFBSSx1QkFBTyxLQUFLLFVBQVUsTUFBSyxNQUFLLENBQUMsQ0FBQztBQUFBLE1BQ3RDLFNBQVMsS0FBUDtBQUNELGdCQUFRLE1BQU0sK0JBQStCLEdBQUc7QUFDaEQsWUFBSSx1QkFBTyxpQkFBaUI7QUFBQSxNQUM3QjtBQUFBLElBQ0QsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sZ0JBQWdCLE9BQU8sUUFBZ0IsU0FBdUI7QUFDN0QsZ0JBQVEsSUFBSSxPQUFPLGFBQWEsQ0FBQztBQUNqQyxjQUFNLFNBQVMsT0FBTyxhQUFhO0FBRW5DLFlBQUksQ0FBQyxRQUFRO0FBQ1osY0FBSSx1QkFBTyxxQkFBcUI7QUFDaEM7QUFBQSxRQUNEO0FBRUEsY0FBTSxPQUFPLE1BQU0sTUFBTyxLQUFLLEVBQUUsT0FBTyxrQkFBa0IsVUFBVSxDQUFDLEVBQUMsTUFBTSxRQUFRLFNBQVMsS0FBSyxVQUFVLE1BQU0sRUFBQyxDQUFDLEVBQUUsQ0FBQztBQUN2SCxlQUFPLGlCQUFpQixLQUFLLFVBQVUsS0FBSyxRQUFRLE9BQU8sQ0FBQztBQUFBLE1BQzdEO0FBQUEsSUFDRCxDQUFDO0FBQ0QsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixnQkFBZ0IsT0FBTyxRQUFnQixTQUF1QjtBQUM3RCxjQUFNLFNBQVMsT0FBTyxhQUFhO0FBQ25DLGNBQU0sZUFBZTtBQUNyQixjQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sY0FBYyxZQUFZO0FBRXRELFlBQUksdUJBQU8sK0JBQStCO0FBRTFDLFlBQUksQ0FBQyxRQUFRO0FBQ1osY0FBSSx1QkFBTyxxQkFBcUI7QUFDaEM7QUFBQSxRQUNEO0FBRUEsWUFBSSxTQUFTLE1BQ2I7QUFDQyxjQUFJLHVCQUFPLDJCQUEyQjtBQUN0QztBQUFBLFFBQ0Q7QUFFQSxjQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLElBQUk7QUFFOUMsY0FBTSxpQkFBaUI7QUFFdkIsY0FBTSxhQUFhLEtBQUssVUFBVSxNQUFNLEVBQUUsT0FBTyxLQUFLLFVBQVUsY0FBYyxDQUFDO0FBRS9FLFlBQUksdUJBQU8sc0JBQXNCO0FBQ2pDLGNBQU0sT0FBTyxNQUFNLE1BQU8sS0FBSyxFQUFFLE9BQU8sa0JBQWtCLFVBQVUsQ0FBQyxFQUFDLE1BQU0sUUFBUSxTQUFTLFdBQVUsQ0FBQyxFQUFFLENBQUM7QUFDM0csZUFBTyxpQkFBaUIsS0FBSyxRQUFRLFFBQVEsUUFBUSw2QkFBNkIsRUFBRSxFQUFFLEtBQUssQ0FBQztBQUFBLE1BQzdGO0FBQUEsSUFDRCxDQUFDO0FBQ0QsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixnQkFBZ0IsT0FBTyxRQUFnQixTQUF1QjtBQUM3RCxjQUFNLFNBQVMsT0FBTyxhQUFhO0FBQ25DLGNBQU0sY0FBYztBQUNwQixjQUFNLFdBQVcsS0FBSyxJQUFJLE1BQU0sY0FBYyxXQUFXO0FBRXpELFlBQUksdUJBQU8sK0JBQStCO0FBRTFDLFlBQUksQ0FBQyxRQUFRO0FBQ1osY0FBSSx1QkFBTyxxQkFBcUI7QUFDaEM7QUFBQSxRQUNEO0FBRUEsWUFBSSxhQUFhLE1BQ2pCO0FBQ0MsY0FBSSx1QkFBTyw0QkFBNEI7QUFDdkM7QUFBQSxRQUNEO0FBRUEsWUFBSSxvQkFBb0I7QUFFeEIsbUJBQVcsUUFBUSxLQUFLLElBQUksTUFBTSxpQkFBaUIsR0FDbkQ7QUFDQyxjQUFJLEtBQUssS0FBSyxXQUFXLFlBQVk7QUFBRztBQUV4QyxnQkFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQzlDLCtCQUFxQjtBQUFBO0FBQUE7QUFBQSxJQUFnQixLQUFLO0FBQUE7QUFBQSxFQUFlO0FBQUEsUUFDMUQ7QUFFQSxZQUFJLHVCQUFPLGdEQUFnRDtBQUUzRCxjQUFNLFFBQVEsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLFFBQVE7QUFFaEQsY0FBTSxhQUFhLEtBQUssVUFBVSxpQkFBaUIsRUFBRSxPQUFPLEtBQUssVUFBVSxNQUFNLEVBQUUsT0FBTyxLQUFLLFVBQVUsS0FBSyxDQUFDLENBQUM7QUFFaEgsWUFBSSx1QkFBTyxzQkFBc0I7QUFDakMsY0FBTSxPQUFPLE1BQU0sTUFBTyxLQUFLLEVBQUUsT0FBTyxrQkFBa0IsVUFBVSxDQUFDLEVBQUMsTUFBTSxRQUFRLFNBQVMsV0FBVSxDQUFDLEVBQUUsQ0FBQztBQUMzRyxlQUFPLGlCQUFpQixLQUFLLFFBQVEsUUFBUSxRQUFRLDZCQUE2QixFQUFFLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFDN0Y7QUFBQSxJQUNELENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLGVBQWUsQ0FBQyxhQUFzQjtBQUVyQyxjQUFNLGVBQWUsS0FBSyxJQUFJLFVBQVUsb0JBQW9CLDRCQUFZO0FBQ3hFLFlBQUksY0FBYztBQUdqQixjQUFJLENBQUMsVUFBVTtBQUNkLGdCQUFJLFlBQVksS0FBSyxHQUFHLEVBQUUsS0FBSztBQUFBLFVBQ2hDO0FBR0EsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRDtBQUFBLElBQ0QsQ0FBQztBQUdELFNBQUssY0FBYyxJQUFJLGlCQUFpQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBSXZELFNBQUssaUJBQWlCLFVBQVUsU0FBUyxDQUFDLFFBQW9CO0FBQzdELGNBQVEsSUFBSSxTQUFTLEdBQUc7QUFBQSxJQUN6QixDQUFDO0FBR0QsU0FBSyxpQkFBaUIsT0FBTyxZQUFZLE1BQU0sUUFBUSxJQUFJLGFBQWEsR0FBRyxJQUFJLEtBQUssR0FBSSxDQUFDO0FBQUEsRUFDMUY7QUFBQSxFQUVBLFdBQVc7QUFBQSxFQUVYO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7QUFFQSxJQUFNLGNBQU4sY0FBMEIsc0JBQU07QUFBQSxFQUMvQixZQUFZLEtBQVU7QUFDckIsVUFBTSxHQUFHO0FBQUEsRUFDVjtBQUFBLEVBRUEsU0FBUztBQUNSLFVBQU0sRUFBQyxVQUFTLElBQUk7QUFDcEIsY0FBVSxRQUFRLE9BQU87QUFBQSxFQUMxQjtBQUFBLEVBRUEsVUFBVTtBQUNULFVBQU0sRUFBQyxVQUFTLElBQUk7QUFDcEIsY0FBVSxNQUFNO0FBQUEsRUFDakI7QUFDRDtBQUVBLElBQU0sbUJBQU4sY0FBK0IsaUNBQWlCO0FBQUEsRUFHL0MsWUFBWSxLQUFVLFFBQTBCO0FBQy9DLFVBQU0sS0FBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2Y7QUFBQSxFQUVBLFVBQWdCO0FBQ2YsVUFBTSxFQUFDLFlBQVcsSUFBSTtBQUV0QixnQkFBWSxNQUFNO0FBRWxCLFFBQUksd0JBQVEsV0FBVyxFQUNyQixRQUFRLFlBQVksRUFDcEIsUUFBUSxlQUFnQixFQUN4QixRQUFRLFVBQVEsS0FDZixlQUFlLG1CQUFtQixFQUNsQyxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQUEsRUFDTDtBQUNEOyIsCiAgIm5hbWVzIjogWyJIZWFkZXJzIiwgInJlc29sdmUiLCAiZmV0Y2giLCAiZmV0Y2giLCAiX19kZWZQcm9wIiwgIk9sbGFtYSIsICJmcyJdCn0K
